--[[

=======================================================================================
	Original creator: Werejew
	Edit log: 
	2020/05/28 - Vintar - added lairs to patrol squad targeting, added surge/emission cover-seeking behavior
	2020/05/29 - Vintar - changed respawn times to be inversely proportional to base count, base respawn time is re-calculated when ownership changes
	2020/05/30 - Vintar - loner/ecolog don't get sent out during emissions, patrol spawns also depend on base count
	2020/06/06 - Vintar - added cover-seeking behavior for psi-storms
	2020/06/23 - Vintar - added sending overflow squads with no valid target to a target from all active levels
	2020/09/22 - Vintar - loner players no longer see other loner bases outside of fog of war
	2020/10/16 - Vintar - Fix resetting base spawn timers from visiting loner/ecolog squads
	2020/10/22 - Vintar - Updated loner targeting to be smarter about attacking hostile resource points
	2020/10/24 - Vintar - Random patrol targeting also accounts for squad powers now, with no more suicide attacks
	2021/02/04 - Vintar - modified functions for Anomaly 1.5.1, more mechanic keywords, new handling of ignored/stationary squads
	2021/02/13 - Vintar - Invasion schema overhauled. Optimization of process_squads. Fixed stationary squads being affected by invasions. Added toggle capability for loner fog of war. Fixed targeting of loner/ecolog bases. Allowed multi-targeting. Duty random patrols target only lairs
	2021/02/19 - Vintar - Added invasion defense logic. New invasion planning logic. Added shuffling of squads to contribute to invasion forces. Re-check targets and invasion when a faction loses a base/resource. Added ability to quickly capture empty terrains. New min/max targets per base added. New overflow squad targeting. Now stores and saves distances between smarts. Added relation penalty for stealing a contested smart. 
	2021/02/22 - Vintar - Better accounting for stationary squads. Bases will no longer donate squads to nearby invasion forces if they are under attack. Invasions are no longer planned on neutral loner/ecolog resources, or empty locations. Underground areas can no longer be targets of bases. Invasions are now also re-calculated upon base/resource loss. Fixed ceasefire check on diplomatic relation hit for 'stealing' smart terrain targets. Fixed formula for invasion size factor linear interpolation. 
	2021/03/02 - Vintar - Useless smarts are hidden with option. Better messaging of player about invasion defense. Active 'forgetting' of loner/ecolog random patrols. Remove squad functionality moved to overflow squads with no valid targets anywhere. Night activity check is now checked once per night per smart. Added immediate invasion capability. Now exlude target base from reinforcement calculation. Random patrols preferentially spawn on allied locations. Loner random patrols can spawn on any neutral location. Code optimizations
	2021/03/08 - Vintar - Monolith can't target south unless actor's faction. Normal factions can't target Radar if Scorcher still on. Fixed lab x8, jup underground not having rare mutants / targeting exclusion
	2021/03/27 - Vintar - Loner/ecolog random patrols tracked again, but only affected by their process functions. Fixed negative level priorities not counting. 
	2021/04/02 - Vintar - Loners/ecolog evacuate neutral positions under attack. Code optimizations to remove unnecessary inv_dist calculations.
	2021/11/09 - Vintar - Overhauled autocapture. Reintroduced 'hide all smarts' functionality via code refactoring. Changed text strings to use st_warfare.xml.
	2022/02/12 - Vintar - fixed rare crash instance of autocapture "owned" base but no squads on that base.
	2022/02/26 - Vintar - added main base attack deprioritization option, monster spawns on already-occupied lairs will be identical to the existing mutant type, UNISG actually prioritizes lab entrances now
	2022/03/06 - Vintar - monster spawn numbers based on level lair capacity
	2022/04/15 - Ace - Fix for crash when dead allied defenders try to send a message after invasion force is defeated
	2022/04/22 - Vintar - Mutants from X8 and Pripyat Underpass can no longer transition out
	2022/04/30 - Vintar - Main base attack prevention also applies to mutants
	
	This file handles the majority of warfare-related script tasks, such as squad behavior,
	targeting, smart terrain updates, ownership checks, patrol behavior, etc.
=======================================================================================

--]]

local enable_debug = false


printd = warfare.printd

hide_smarts = false -- altered by pda_warfare.script

local sfind, is_factions_enemies, is_factions_friends = string.find, game_relations.is_factions_enemies, game_relations.is_factions_friends

-- Timer used for capturing smart terrains. 
point_cap_timers = {}
smart_owners = {}
manual_point = nil
dbg_hud = false

local guard_size = 1							-- number of squads to keep at a base when an invasion is sent out
local currently_surge = false
local reset_defense_timer = {}
local previous_owner = {}										-- have to use this, since using smart.last_owner messes with the pda icons

defense_timers = {}
defense_next_update = {}
patrol_timers = {}
patrol_next_update = {}
spawn_mutant_timers = {}
spawn_mutant_next_update = {}
process_mutant_timers = {}
process_mutant_next_update = {}
loner_timer = {}
loners_next_update = {}
ecolog_timer = {}
ecolog_next_update = {}

smart_terrain_distances = {}				-- store distances when they get used. Save it in warfare.script to avoid lag spikes from continuously measuring distances between smart terrains
under_attack = {}							-- when a smart is under attack, halt squad assignment from that smart until the threat has passed or the point has changed hands

patrol_squads = {}
random_patrols = {}
invasions = {}

local original_target = {}
local surge_checker1 = {}
local surge_checker2 = {}
local invasion_defense_timers = {}
local invasion_defense_next_update = {}
local base_recheck = {}							-- used to keep track of bases/resources of a faction. If they decrease compared to last time it was checked, targets are re-scanned
local resource_recheck = {}
local ceasefire_check = {}						-- used to keep track if a faction changes from enemy to neutral across update cycles. Prevents immediate relation deterioration upon ceasefire
local reinforcements_requested = {}				-- bases will only request reinforcements once per incoming attack to ease computational load
local night_activity_allowed = {}				-- night activity is cleared once per night on a per-smart basis
local actor_informed = {}						-- Players on the same level of an allied defending point will be notified one time about the attack


-- if has_alife_info("bar_deactivate_radar_done") then  --- method to determine scorcher status


-- this variable doesn't get used
control_hold = {}

pda_icons = {
	["stalker"] = "circle_stalker",
	["bandit"] = "circle_bandit",
	["csky"] = "circle_csky",
	["army"] = "circle_army",
	["freedom"] = "circle_freedom",
	["dolg"] = "circle_dolg",
	["ecolog"] = "circle_ecolog",
	["killer"] = "circle_killer",
	["monolith"] = "circle_monolith",
	["renegade"] = "circle_renegade",
	["greh"] = "circle_greh",
	["isg"] = "circle_isg",
	["zombied"] = "circle_zombied",
	["none"] = "circle_empty",
	["target"] = "circle_target",
}

-- [1] = trader count
-- [2] = mechanic count
-- [3] = medic count
-- [4] = barman count
-- [5] = leader count
local uniques = {	
	["mar_smart_terrain_base"] = { 1, 1, 1, 1, 1 },
	["ds2_domik_st"]           = { 1, 1, 0, 0, 0 },
	["esc_smart_terrain_5_7"]  = { 1, 1, 0, 0, 0 },
	["esc_smart_terrain_3_16"] = { 1, 1, 0, 0, 0 },
	["gar_smart_terrain_3_5"]  = { 1, 0, 0, 0, 0 },
	["val_smart_terrain_7_3"]  = { 0, 1, 0, 0, 0 },
	["val_smart_terrain_7_4"]  = { 1, 0, 0, 0, 0 },
	["val_smart_terrain_7_5"]  = { 0, 0, 1, 0, 1 },
	["agr_smart_terrain_1_6"]  = { 1, 1, 1, 1, 1 },
	["bar_visitors"]           = { 0, 1, 0, 1, 0 },
	["bar_dolg_general"]       = { 1, 0, 1, 0, 0 },
	["bar_dolg_bunker"]		   = { 0, 0, 0, 0, 1 },
	["mil_smart_terrain_7_7"]  = { 0, 1, 1, 1, 1 },
	["mil_smart_terrain_7_10"] = { 1, 0, 0, 0, 0 },
	["mil_smart_terrain_7_12"] = { 0, 0, 0, 0, 0 },	 -- location for 7_10 uniques
	["cit_killers"]            = { 1, 1, 1, 1, 1 },
	["pri_monolith"]           = { 1, 1, 0, 0, 1 },
	["kbo_terrain"]            = { 1, 1, 0, 0, 0 },
	["pri_a18_smart_terrain"]  = { 1, 1, 0, 0, 0 },
	["pri_a16"]                = { 1, 1, 0, 0, 0 },
	["trc_sim_20"]             = { 1, 1, 0, 0, 0 },
	["yan_smart_terrain_6_4"]  = { 1, 1, 0, 1, 0 },
	["jup_a6"]                 = { 1, 1, 1, 1, 0 },
	["jup_b41"]                = { 1, 1, 0, 0, 1 },
	["jup_a12"]                = { 1, 1, 0, 0, 0 },
	["jup_b208"]               = { 1, 1, 0, 0, 0 },
	["zat_stalker_base_smart"] = { 1, 1, 1, 1, 0 },
	["zat_b40_smart_terrain"]  = { 1, 1, 0, 0, 0 },
}

-- 1 if location has unique questgivers, 2 if not
local main_bases = {	
	["mar_smart_terrain_base"] = 1,  -- Clear Sky Base
	["esc_smart_terrain_2_12"] = 1,  -- Rookie Village
	["val_smart_terrain_7_3"]  = 2,  -- Bandit Base
	["val_smart_terrain_7_4"]  = 1,
	["val_smart_terrain_7_5"]  = 1,
	["agr_smart_terrain_1_6"]  = 1,  -- Army Base
	["agr_smart_terrain_1_6_near_1"]  = 1,
	["agr_smart_terrain_1_6_near_2"]  = 1,  -- location of some 1_6 uniques
	["bar_dolg_general"]       = 1,  -- Duty Base
	["bar_dolg_bunker"]		   = 1,
	["bar_zastava"]		   	   = 2,  -- guard posts
	["bar_zastava_2"]		   = 2,
	["mil_smart_terrain_7_7"]  = 1,  -- Freedom Base
	["mil_smart_terrain_7_8"]  = 2,  -- entrance
	["mil_smart_terrain_7_10"] = 1,
	["mil_smart_terrain_7_12"] = 1,	 -- location for 7_10 uniques
	["cit_killers"]            = 1,  -- Mercenary Base
	["red_smart_terrain_3_2"]  = 1,  -- Sin Base
	["pri_monolith"]           = 1,  -- Monolith Base
	["pri_a18_smart_terrain"]  = 1,  -- Laundromat Base
	["pri_a16"]                = 1,  -- Stranded Mercenaries
	["yan_smart_terrain_6_4"]  = 1,  -- Scientist Bunker
	["jup_a6"]                 = 1,  -- Yanov Station
	["jup_b41"]                = 1,  -- Scientist Bunker
	["zat_stalker_base_smart"] = 1,  -- Skadovsk
}

-- list of smarts at laboratory entrances
local lab_entrance_smarts = {
	["agr_smart_terrain_1_6"]   = true,			-- Agroprom base
	["agr_smart_terrain_1_6_near_1"]  = true,	-- Agroprom base
	["agr_smart_terrain_1_6_near_2"]  = true,	-- Agroprom base
	["val_smart_terrain_1_2"]  	= true,			-- X18 entrance
	["yan_smart_terrain_2_4"]  	= true,			-- X16 entrance
	["rad_antenna_monolith"]  	= true,			-- X19 base
	["rad_antenna_patrol"]  	= true,			-- X19 base
	["rad_antenna_camper"]  	= true,			-- X19 entrance
	["jup_b8_smart_terrain"]    = true,			-- Jupiter plant
	["jup_b219"]			    = true,			-- Jupiter plant
	["jup_a9"]			   		= true,			-- Jupiter plant
	["jup_b208"]			   	= true,			-- Jupiter underground entrance (from Jupiter)
	["zat_b100"]			   	= true,			-- Iron Forest (near Gauss lab)
	["zat_b103_merc_smart"]		= true,			-- Substation Workshop
	["pri_a15"]			   		= true,			-- Jupiter underground entrance (from Outskirts)
	["pri_a16"]			   		= true,			-- Laundromat
	["kbo_terrain"]		   		= true,			-- X8 entrance
	["pri_b306"]		   		= true,			-- X8 entrance
	["aes_smart_terrain_monolit_blockpost4"] = true, -- Sarcophagus entrance
	["gen_smart_terrain_lab_entrance"] 		 = true, -- Generators Warlab entrance
}

-- Number of mutant squads allowed on each level (on a 1.0 mutant pop factor). Mixed lair/territories count for half the mutant capacity
-- This should be changed if the # of lairs changes at any point in the future
local monster_level_capacity = {
	[1] = 17,	-- Marsh [13 lairs, 17 cap]
	[2] = 9,	-- Cordon [9 lairs, 9 cap]
	[3] = 15,	-- Garbage [11 lairs, 15 cap]
	[4] = 12,	-- Agroprom [5 lairs, 12 cap]
	[5] = 12,	-- Darkscape [8 lairs, 12 cap]
	[6] = 13,	-- Dark Valley [11 lairs, 13 cap]
	[7] = 6,	-- Rostok Bar [2 lairs, 6 cap]
	[8] = 3,	-- Wild Territory [3 lairs, 3 cap]
	[9] = 5,	-- Warehouses [5 lairs, 5 cap]
	[10] = 8,	-- Yantar [8 lairs, 13 cap]
	[11] = 9,	-- Dead City [6 lairs, 9 cap]
	[12] = 6,	-- Limansk [3 lairs, 6 cap]
	[13] = 21,	-- Radar [12 lairs, 21 cap]
	[14] = 12,	-- Red Forest [7 lairs, 12 cap]
	[15] = 0,	-- Hospital
	[16] = 14,	-- Pripyat [10 lairs, 14 cap]
	[17] = 13,	-- NPP South [6 lairs, 13 cap]
	[18] = 6,	-- NPP North [3 lairs, 6 cap]
	[19] = 4,	-- Generators [4 lairs, 4 cap]
	[20] = 6,	-- Agroprom Underground [4 lairs, 6 cap]
	[21] = 6,	-- X18 [6 lairs, 6 cap]
	[22] = 8,	-- X16 [4 lairs, 8 cap]
	[23] = 3,	-- X19 [3 lairs, 3 cap]
	[24] = 10,	-- Sarcophagus [4 lairs, 10 cap]
	[25] = 2,	-- Monolith Control
	[26] = 0,	-- Generators Warlab
	[27] = 50,	-- Zaton [39 lairs, 50 cap]
	[28] = 38,	-- Jupiter [30 lairs, 38 cap]
	[29] = 23,	-- Jupiter Underpass [8 lairs, 23 cap]
	[30] = 15,	-- Outskirts [15 lairs, 15 cap]
	[31] = 5,	-- X8 [1 lair, 5 cap]
	[32] = 19,	-- Truck Cemetery [15 lairs, 19 cap]
	[33] = 0,	-- Test Level
	[34] = 4,	-- Village
}

local clr_gr = utils_xml.get_color("ui_gray_1")
local clr_w = utils_xml.get_color("white")
local clr_o = utils_xml.get_color("d_orange")
local clr_r = utils_xml.get_color("d_red")
local clr_c = utils_xml.get_color("d_cyan")
local clr_b = utils_xml.get_color("pda_blue")
local clr_y = utils_xml.get_color("white")

local str_wrfr = {}
function refresh_strings()
	str_wrfr[1] = game.translate_string("st_wrfr_smrt_auto_capture")
	str_wrfr[2] = game.translate_string("st_wrfr_prop_base")
	str_wrfr[3] = game.translate_string("st_wrfr_prop_resource")
	str_wrfr[4] = game.translate_string("st_wrfr_prop_territory")
	str_wrfr[5] = game.translate_string("st_wrfr_prop_lair")
	str_wrfr[6] = game.translate_string("st_wrfr_prop_faction")
	str_wrfr[7] = game.translate_string("st_wrfr_prop_curr_popu")
	str_wrfr[8] = game.translate_string("st_wrfr_prop_max_popu")
	str_wrfr[9] = game.translate_string("st_wrfr_prop_resource_count")
	str_wrfr[10] = game.translate_string("st_wrfr_prop_time_capture")
	str_wrfr[11] = game.translate_string("st_wrfr_prop_next_defense")
	str_wrfr[12] = game.translate_string("st_wrfr_prop_next_patrol")
	str_wrfr[13] = game.translate_string("st_wrfr_prop_time_culc_hr")
	str_wrfr[14] = game.translate_string("st_wrfr_prop_time_culc_min")
	str_wrfr[15] = game.translate_string("st_wrfr_prop_target")
	str_wrfr[16] = game.translate_string("st_wrfr_prop_invasion_size")
	str_wrfr[17] = game.translate_string("st_wrfr_prop_targets")
	str_wrfr[18] = game.translate_string("st_wrfr_prop_invasion")
	str_wrfr[19] = game.translate_string("st_wrfr_smart_count_warning")
end

function translate_smart_name(name)	
	return (name and game.translate_string("st_" .. name .. "_name") or "")
end

function set_max_population(smart)
	printd(0)
	local stalker_pop_factor = ui_options.get("alife/general/alife_stalker_pop")
	local monster_pop_factor = ui_options.get("alife/general/alife_mutant_pop")
	
	if (smart.props and (smart.props.base > 0 or smart.props.resource > 0 or smart.props.territory > 0)) then
		smart.max_population = round_idp(math.max(1, smart.default_max_population * stalker_pop_factor))
	else
		smart.max_population = round_idp(math.max(1, smart.default_max_population * monster_pop_factor))
	end
	printd(1)
end

function smart_terrain_on_update(smart)
	printd(0, "smart_terrain_on_update "..smart:name())	

	if not (IsWarfare()) then
		return
	end

	-- avoid vanilla respawns
	local curr_time = game.get_game_time()
	smart.last_respawn_update = curr_time
		
	-- check if level_id is set, if not set it.
	if not (smart.level_id) then
		smart.level_id = game_graph():vertex(smart.m_game_vertex_id):level_id()
	end
	
	if not (smart.first_update) then
		smart.first_update = true

        -- hackish and will result in the squatting squads, but meh. 
        if (smart.max_population == 0) then
            smart.max_population = 1
        end
		
		smart.default_max_population = smart.max_population
	
		if (smart_owners[smart.id]) then
			smart.owning_faction = smart_owners[smart.id]
			smart.last_owner = smart_owners[smart.id]
		else
			smart.owning_faction = "none"
			smart.last_owner = "none"
		end

		set_max_population(smart)		
		
		smart.global_position = global_position.from(smart)
	end
	
	check_owner(smart)
	
	if smart.owning_faction and smart.owning_faction ~= "none" and not warfare_options.options.factions[smart.owning_faction].participate_in_warfare then
		return
	end
	
	check_unique_npcs(smart)
	
	if not (smart.player_target_smarts) then
		smart.player_target_smarts = {}
	end

	if not (smart.target_smarts) then
		smart.target_smarts = {}
	end
	
	if not (smart.target_smart_count) then
		smart.target_smart_count = 0
	end
	
	if not (warfare.initialized) then
		printd(1, smart:name())
		return
	end
	
	process_manual_capture(smart)
	process_squads(smart)

	if (smart.owning_faction ~= "none" and warfare_options.options.factions[smart.owning_faction] and warfare_options.options.factions[smart.owning_faction].participate_in_warfare) then
		if (smart.props) then
			if (smart.props.base > 0) then			
				-- base-specific updates
				update_resources(smart)
				spawn_defense(smart)				
				process_targets(smart)

				if not (patrol_squads[smart.id]) then
					patrol_squads[smart.id] = {}
				end
				
				spawn_patrols(smart)				
				process_patrols(smart)

				process_loners(smart)
				process_ecolog(smart)
				
			else			
				-- resource, lair, and territory updates
				process_loners(smart)
				process_ecolog(smart)
				
				surge_behavior(smart)
		
			end
			
			process_invasion_defense(smart)
			
		end
	elseif (smart.owning_faction == "none") then			-- location is empty, consider spawning mutants or changing location of existing mutants
		spawn_mutants(smart)
		process_mutants(smart)
	end
	
    printd(2, smart:name())
end

function process_manual_capture(smart)	

	-- use old method if the setting is enabled
	if (warfare_options.options.use_old_auto_capture) then
		process_manual_capture_old(smart)
		return
	end

	-- loners and ecolog can't capture points
	if (warfare.actor_faction == "stalker" or warfare.actor_faction == "ecolog") then
		manual_point = nil
		return
	end
	
	-- use old method if your faction has zero bases
	if (warfare_factions.faction_information[warfare.actor_faction].base_count == 0) then
		process_manual_capture_old(smart)
		return
	end
	
	-- pause functionality during surges
	if currently_surge then
		return
	end

	-- STEP 1: when PDA is active on empty smart, check validity for capture, any nearby bases to send a squad, and pass the info to STEP 2
	-- if not already autocapturing and autocapture is enabled, begin the autocapture process
	local manual_check = manual_point and manual_point[5]		-- if there is no flag integer on the manual capture, need to make one
	if (manual_check == nil) and ( (warfare_options.options.enable_auto_capture == true) or (manual_point and (manual_point[1] == smart.id)) ) then		-- proceed if no manual_point data and autocapture is enabled, or if existing manual_point data lacks flag
		local lvl = game_graph():vertex(smart.m_game_vertex_id):level_id()

		if (lvl == get_player_level_id() and warfare_levels.level_information[lvl]) then	

			-- only proceed if PDA is active
			local obj_pda = db.actor:active_item()

			if (obj_pda and sfind(obj_pda:section(),"device_pda") and obj_pda:condition() >= obj_pda:power_critical()) then
				for i,sm in pairs(warfare_levels.level_information[lvl].smarts) do
					local smart = sm and alife_object(sm)
					-- valuable unowned smarts on level are checked
					if (smart and smart.props and (smart.props.base > 0 or smart.props.resource > 0 or smart.props.territory > 0) and smart.owning_faction == "none") then
						local dist = warfare.distance_to_xz_sqr(smart.position, alife():actor().position)
						-- within capture distance
						if (dist <= math.pow(warfare_options.options.auto_capture_max_distance, 2)) then
							local closest_base
							local targeting_squad
							
							-- check for ally squads already targeting, cancel capture if already targeting
							local squads = SIMBOARD.smarts[smart.id].squads							-- get info of all squads targeting location
							for sid,_ in pairs(squads) do
								local squad = sid and alife_object(sid)
								local faction = squad:get_squad_community()							-- get faction of squads
								if (faction == warfare.actor_faction) and (not warfare.ignore[squad:section_name()]) then
									-- squad already targeting
									targeting_squad = squad.id
								end
							end
							
							-- check for nearby bases in the vicinity
							local smartCollection = {}
							if not targeting_squad then
								local linked = level_targets.level_links[lvl]	
								local currentLevelSmarts = warfare_levels.level_information[lvl].smarts
								
								for i=1,#currentLevelSmarts do
									local other = currentLevelSmarts[i] and alife_object(currentLevelSmarts[i])
									-- add any allied base to list
									if other and other.owning_faction and (other.owning_faction == warfare.actor_faction) and other.props and (other.props.base > 0) then
										local distance = fetch_smart_distance(smart,other)
										smartCollection[#smartCollection+1] = { distance, other.id }
									end
								end

								-- did not find an on-level base, search linked levels
								if not (#smartCollection > 0) then
									for lvl,_ in pairs(linked) do
										local smarts = warfare_levels.level_information[lvl].smarts

										for i=1,#smarts do
											local other = smarts[i] and alife_object(smarts[i])
											-- add any allied base to list
											if other and other.owning_faction and (other.owning_faction == warfare.actor_faction) and other.props and (other.props.base > 0) then
												local distance = fetch_smart_distance(smart,other)
												smartCollection[#smartCollection+1] = { distance, other.id }
											end
										end
									end
								end
							end

							if (#smartCollection > 0) then
								table.sort(smartCollection, function(a, b)
									return math.abs(a[1]) < math.abs(b[1])
								end)
								
								closest_base = smartCollection[1][2]		-- found a base, use that
							end
							
							-- store autocapture info, will be used to give messages even if invalid
							manual_point = { smart.id, game.get_game_time(), closest_base, targeting_squad, 1 }
							local warfareName = translate_smart_name(smart:name())	or smart:name()
							actor_menu.set_msg(1, strformat(str_wrfr[1], tostring(warfareName)), 3)
							break
						end
					end
				end
				
				local manual_check2 = manual_point and manual_point[5]
				if not manual_check2 then
					manual_point = nil		-- actor has attempted a manual capture beyond the capture distance - kill the attempt
					--printf("Warfare: kill invalid manual capture attempt")
				end
				
			end
		end
	
	-- autocapture data already exists for this smart
	elseif manual_check and (manual_point[1] == smart.id) then
		local startTime = manual_point[2]
		local diff = round_idp(game.get_game_time():diffSec(startTime))
		-- STEP 2: wait for a few seconds before beginning autocapture process
		-- actor hasn't called for a squad yet
		if (manual_point[5] == 1) then
			-- wait 2 seconds before player calls for a squad
			if (diff >= 20) then
				local smart_translated = translate_smart_name(smart:name()) or smart:name()
				local sender_header = strformat("%s, %s", db.actor:character_name(), game.translate_string("st_dyn_news_comm_" .. warfare.actor_faction .. "_" .. 6))
				local rnd_request = round_idp(math.random()*4)+1	-- 5 options in st_warfare.xml
				local msg = strformat(game.translate_string("st_wrfr_request_squad_"..rnd_request), smart_translated)		-- get a random string and then add the correct smart name
				dynamic_news_helper.send_tip( msg, sender_header, 0, 10, db.actor:character_icon(), "beep_1", "npc" )
				manual_point[5] = 0			-- actor has called for a squad, move to STEP 3
			end
		
		-- STEP 3: respond to the player, spawn a squad, set target, and increase spawn timer
		elseif (manual_point[5] == 0) then
			if (diff >= (warfare_options.options.auto_capture_wait_time*60)) then
				local closest_base = manual_point[3] and alife_object(manual_point[3])
				local targeting_squad = manual_point[4] and alife_object(manual_point[4])
				
				-- base exists
				if closest_base then
					-- spawn squad at base and send it
					local section = faction_expansions.get_spawn_section(warfare.actor_faction, warfare_factions.faction_information[warfare.actor_faction].resource_count)
					local squad = utils_obj.create_squad(section, closest_base:name())
					sim_squad_warfare.set_target(squad, smart.id)
					-- increase spawn timer of that base
					local faction_bases = warfare_factions.faction_information[warfare.actor_faction].base_count + warfare_options.options.factions[warfare.actor_faction].base_count_modifier
					local min_respawn = warfare_options.options.factions[warfare.actor_faction].min_faction_respawn
					local max_respawn = warfare_options.options.factions[warfare.actor_faction].max_faction_respawn
					local respawn_time = warfare.lerp(min_respawn, max_respawn, clamp(faction_bases / warfare.base_count, 0, 1))
					local respawn_multiplier = 1.2
					defense_next_update[closest_base.id] = defense_next_update[closest_base.id] + respawn_multiplier * respawn_time  -- add respawn penalty to base
					-- get info of base NPC for message info
					local squads = SIMBOARD.smarts[closest_base.id].squads
					local base_squad
					local sender
					for sid,_ in pairs(squads) do
						local squad = sid and alife_object(sid)
						local faction = squad:get_squad_community()							-- get faction of squads
						
						if (faction == warfare.actor_faction) then
							base_squad = squad
							break
						end
					end
					
					if base_squad then
						for guy in base_squad:squad_members() do
							local person = guy.object or guy.id and alife():object(guy.id)
							if person then
								sender = person
								break
							elseif guy then
								sender = guy
								break
							end
						end
					end
					
					-- inform player that squad is on the way
					local sender_header = strformat("%s, %s", sender:character_name(), game.translate_string("st_dyn_news_comm_" .. warfare.actor_faction .. "_" .. 6))
					local smart_translated = translate_smart_name(closest_base:name()) or closest_base:name()
					local rnd_confirm = round_idp(math.random()*4)+1
					local msg = strformat(game.translate_string("st_wrfr_respond_affirmative_"..rnd_confirm), smart_translated)		-- get a random string and then add the correct smart name
					dynamic_news_helper.send_tip( msg, sender_header, 0, 10, sender:character_icon(), "beep_1", "npc" )
					manual_point[5] = -1		-- switch to STEP 4
				
				-- Squad was already en route to the position, so inform actor
				elseif targeting_squad then
					-- get info of traveling squad NPC for message info
					local sender
					for guy in targeting_squad:squad_members() do
						local person = guy.object or guy.id and alife():object(guy.id)
						if person then
							sender = person
							break
						elseif guy then
							sender = guy
							break
						end
					end
					
					-- squad already targeting, inform player
					local sender_header = strformat("%s, %s", sender:character_name(), game.translate_string("st_dyn_news_comm_" .. warfare.actor_faction .. "_" .. 6))
					local smart_translated = translate_smart_name(smart:name()) or smart:name()
					local rnd_ontheway = round_idp(math.random()*4)+1
					local msg = strformat(game.translate_string("st_wrfr_respond_ontheway_"..rnd_ontheway), smart_translated)		-- get a random string and then add the correct smart name
					dynamic_news_helper.send_tip( msg, sender_header, 0, 10, sender:character_icon(), "beep_1", "npc" )
					manual_point[5] = -1		-- switch to STEP 4
				
				-- no bases were in range of the position, inform actor
				else
					-- no bases were in range, inform player
					local icon = warfare.actor_faction
					local rnd_deny = round_idp(math.random()*4)+1
					local text = game.translate_string("st_wrfr_respond_negative_"..rnd_deny)
					news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
					manual_point[5] = -1		-- switch to STEP 4
				end
			end
		
		-- STEP 4: prevent autocapture functions from triggering again until actor clears the area
		-- reset autocapture variables from a failed autocapture once actor has moved away from the area
		elseif (manual_point[5] == -1) then
			local dist = warfare.distance_to_xz_sqr(smart.position, alife():actor().position)

			if (dist > math.pow(warfare_options.options.auto_capture_max_distance, 2)) then
				manual_point = nil
			end
		end
	end
end

-- old method of autocapture, which is used depending on settings.
function process_manual_capture_old(smart)	
	local lvl = game_graph():vertex(smart.m_game_vertex_id):level_id()

	if (manual_point == nil) and (warfare_options.options.enable_auto_capture) then
		if (lvl == get_player_level_id() and warfare_levels.level_information[lvl]) then	
			for i,sm in pairs(warfare_levels.level_information[lvl].smarts) do			
				local smart = sm and alife_object(sm)
				if (smart and smart.props and (smart.props.base > 0 or smart.props.resource > 0) and smart.owning_faction == "none") then
					local dist = warfare.distance_to_xz_sqr(smart.position, alife():actor().position)
					if (dist <= math.pow(warfare_options.options.auto_capture_max_distance, 2)) then
						manual_point = { smart.id, game.get_game_time(), }
						local warfareName = translate_smart_name(smart:name())	or smart:name()					
						actor_menu.set_msg(1, strformat(str_wrfr[1], tostring(warfareName)), 3) 
						break
					end
				end
			end
		end
	end

	if (manual_point and manual_point[1] and manual_point[2]) then
		if (manual_point[1] == smart.id) then
			if (smart.owning_faction ~= "none") then
				manual_point = nil
				process_manual_capture(smart)
				return
			end
		
			local startTime = manual_point[2]
			
			local diff =  round_idp(game.get_game_time():diffSec(startTime)/60)
					
			if (diff >= (warfare_options.options.auto_capture_wait_time)) then
				manual_point = nil
				
				local targeting = squad_count(smart, warfare.actor_faction)
				
				if (targeting < smart.max_population) then
					local section = faction_expansions.get_spawn_section(warfare.actor_faction, warfare_factions.faction_information[warfare.actor_faction].resource_count)
					local squad = utils_obj.create_squad(section, smart:name())
					sim_squad_warfare.set_target(squad, smart.id)
				end
			else		
				local obj = manual_point[1] and alife_object(manual_point[1])

				if (obj) then
					local dist = warfare.distance_to_xz_sqr(obj.position, alife():actor().position)
					
					if (dist > math.pow(warfare_options.options.auto_capture_max_distance, 2)) then
						manual_point = nil
					end
				end
			end
		end
	end
end



function process_squads(smart)
	if not (smart.process_squads_time) or (game.get_game_time():diffSec(smart.process_squads_time) >= smart.next_process_squads_time*60) then
		smart.process_squads_time = game.get_game_time()
		smart.next_process_squads_time = math.random(5, 15)				-- default 1 to 5, made longer to ease script load
	else
		return
	end

	if currently_surge then
		return
	end

	-- don't process squads while under attack
	if under_attack[smart.id] then
		return
	end

	printd(0, smart:name())

	set_max_population(smart)

	local squads = SIMBOARD.smarts[smart.id].squads
	
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)

		-- don't operate on ignore_list squads or story squads, or squads that are not idle
		if (squad) and (squad.registered_with_warfare) and (not warfare.ignore[squad:section_name()]) and (not sim_offline_combat.stationary_squads[squad:section_name()]) and (squad.current_action == 1) then
			local faction = squad:get_squad_community()

			if (faction ~= "stalker") and (faction ~= "ecolog") then									-- only operate on non-loner, non-ecolog squads
				-- Idle random patrols will get re-tasked
				if (random_patrols[squad.id]) then
					if (math.random(100) <= 20) then													-- 20% chance of moving after a given update
						local target = find_random_patrol_target(smart, faction, sid)

						if (target) then
							sim_squad_warfare.set_target(squad, target)
						end
					end
				-- Idle patrol squads will get re-tasked
				elseif (squad.patrol_table) then
					local patrol_target = find_patrol_target(smart,nil,squad)	

					if (patrol_target) then
						sim_squad_warfare.set_target(squad, patrol_target.id)
					end
				-- Idle overflow and lair-dwelling squads will get re-tasked
				else
					if (smart.props.base > 0 or smart.props.resource > 0 or smart.props.territory > 0) then
						local removeSquad = false
						local regular_squads,sq_pow,stationary_sq_num = squad_count_detailed(smart, faction)
						local isDaylight = (level.get_time_hours() > 5 and level.get_time_hours() < 22)
						
						-- do not move away from a loner/ecologist-owned pure resource
						if (faction ~= "monster" and faction ~= smart.owning_faction and not is_factions_enemies(faction, smart.owning_faction)) and not ((smart.owning_faction == "stalker" or smart.owning_faction == "ecolog") and (smart.props.resource > 0 and smart.props.base < 1)) then
							local targets = find_targets(smart, faction)
							pick_target(smart, squad, targets)
						
						-- overflow squads can be moved off during daylight hours, or if smart is cleared for night activity (within process_targets)
						elseif isDaylight or ( night_activity_allowed[smart.id] and night_activity_allowed[smart.id] == 1 ) then
							local invasion_force_size = invasions[smart.id] and invasions[smart.id][2] or 0
							local guards = math.max(guard_size, stationary_sq_num)
							local max_allowable_size = math.max((invasion_force_size + guards), smart.max_population)							-- invasion prep allows temporary overflow at a given base

							if (regular_squads + stationary_sq_num > max_allowable_size) then
								removeSquad = true
							end

							-- find target for overflow squad, when manual control is off
							if (faction ~= "monster" and removeSquad) and not ((faction == warfare.actor_faction) and (pda_actor.manual_control) and not warfare_options.options.overflow_override) then
								local targets = find_targets_for_overflow(smart, faction)
								if (#targets > 0) then
									-- linked level target found
									pick_target(smart, squad, targets, true)
								else
									-- overflow squad with no valid linked level targets
									local new_targets = find_targets_for_overflow(smart, faction, true)				-- find target on any level for overflow squad (third field set to true)
									pick_target(smart, squad, new_targets, true)
									
									-- if no targets anywhere within the Zone could be found, delete the squad (when smart_pop_cap is enabled)
									if (#new_targets < 1) and (not warfare_options.options.disable_smart_pop_cap) then
										sim_squad_warfare.remove_squad(squad)
										squad:remove_squad()
									end
								end
							end
							
						end
					-- move squads sitting on useless terrains, unless actor manual control enabled. monolith exempt
					elseif (faction ~= "monster" and faction ~= "monolith" and faction ~= "zombied") and not ((faction == warfare.actor_faction) and (pda_actor.manual_control)) then
						local targets = find_targets_for_overflow(smart, faction)
						if (#targets > 0) then
							pick_target(smart, squad, targets, true)
						else
							local new_targets = find_targets_for_overflow(smart, faction, true)
							pick_target(smart, squad, new_targets, true)
						end
					end
				end
			end
		end
	end
    
    printd(1, smart:name())
end



function surge_behavior(smart)
	if not (surge_checker1[smart.id]) or (game.get_game_time():diffSec(surge_checker1[smart.id]) >= surge_checker2[smart.id]*60) then
		surge_checker1[smart.id] = game.get_game_time()
		surge_checker2[smart.id] = math.random(1, 5)
	else
		return
	end
	
	local emission = surge_manager.get_surge_manager()
	local psistorm = psi_storm_manager.get_psi_storm_manager()
	
	if (emission.started) or (psistorm.started) then	
		currently_surge = true
		if (smart.is_on_actor_level) and (smart.props) and (smart.props.surge < 1) then						-- only operate on terrains/squads on player's level that don't have shelter
			local squads = SIMBOARD.smarts[smart.id].squads
			
			if (squads) then								-- ignore if no squads present
				local level_info = warfare_levels.level_information[smart.level_id]
				local shelter_targets = {}
				
				for sid,_ in pairs(squads) do
					local squad = sid and alife_object(sid)
					local faction = squad:get_squad_community()
					
					if (faction ~= "monolith") and (faction ~= "monster") and (faction ~= "zombied") and not (axr_companions.companion_squads[sid]) then											-- ignore mutants and zombified, and companion squads
						original_target[squad.id] = smart.id															-- store original target of squad

						if not (#shelter_targets > 0) then																-- find a shelter target only once for this particular terrain
							for i,sm in pairs(level_info.smarts) do
								local other = sm and alife_object(sm)
								
								if (other.props) and (other.props.surge > 0) then
									local dist = warfare.distance_to_xz_sqr(smart.position, other.position)
									
									if not (other.owning_faction) then
										check_owner(other)
									end
									
									if (other.owning_faction == "none") or not is_factions_enemies(faction, other.owning_faction) then			-- non-hostile cover
										shelter_targets[#shelter_targets + 1] = { other.id, dist }
									else
										shelter_targets[#shelter_targets + 1] = { other.id, 2*dist }											-- hostile cover has distance penalty
									end
								end
							end
							
							table.sort(shelter_targets, function(a, b)
								return a[2] < b[2]
							end)
							
						end
						
						if (#shelter_targets > 0) then
							sim_squad_warfare.set_target(squad, shelter_targets[1][1])
						end
						
					end
				end
			end
		end
	end
	
	if (emission.finished) and (psistorm.finished) then
		if original_target then
			for sq_id,sm_id in pairs(original_target) do
				local squad = sq_id and alife_object(sq_id)
				sim_squad_warfare.set_target(squad, sm_id)							-- return squads to original locations
			end
		end
		
		original_target = {}														-- reset for next emission
		currently_surge = false
		
	end

end




-- factions get upset when their targets are stolen from them
-- apply a decrese to relations when a target is stolen, or two factions race to capture the same empty point
-- penalty is based on death_value and the capacity of the 'stolen' smart terrain. Large bases incur large penalties
-- penalties also stack depending on number of bases that were targeting it. If 4 bases were targeting, the penalty is applied 4 times
function faction_diplomatic_penalty(contested_smart_id, faction_1, faction_2)
	
	-- only allowed when dynamic relations is on
	if (not (ui_options.get("alife/general/dynamic_relations"))) then
		return
	end
	
	if (not warfare_options.options.territory_diplo_penalty) then
		return
	end
	
	-- only allowed for factions whose relations are allowed to change
	if (not game_relations.is_relation_allowed(faction_1,faction_2)) or (game_relations.is_faction_pair_unaffected(faction_1,faction_2)) or (faction_1 == faction_2) then
		return
	end
	
	-- cant get upset at loners/ecolog
	if (faction_1 == "stalker") or (faction_1 == "ecolog") or (faction_2 == "stalker") or (faction_2 == "ecolog") then
		return
	end
	
	-- read dynamic relations properties and smart properties
	local ini_r = ini_file("plugins\\dynamic_faction_relations.ltx")
	local delta = ini_r:r_float_ex ("controls" ,"death_value") or 10
	local contested_smart = alife_object(contested_smart_id)
	local penalty_value = (-1) * delta * contested_smart.max_population

	game_relations.change_faction_relations(faction_1, faction_2, penalty_value)
	
	if enable_debug then
		printf("%s is mad that %s has stolen target %s from them! %s to relations", faction_1, faction_2, contested_smart:name(), penalty_value)
	end
end



function process_targets(smart)
	local level_id = game_graph():vertex(smart.m_game_vertex_id):level_id()

	if not (smart.process_targets_time) then
		smart.process_targets_time = game.get_game_time()
		smart.next_process_targets_time = math.random(1, 3)
		base_recheck[smart.id] = warfare_factions.faction_information[smart.owning_faction].base_count + warfare_options.options.factions[smart.owning_faction].base_count_modifier
		resource_recheck[smart.id] = smart.resource_count
		night_activity_allowed[smart.id] = 0					-- initialize
		return
	end

	if (game.get_game_time():diffSec(smart.process_targets_time) >= smart.next_process_targets_time*60) then
		smart.process_targets_time = game.get_game_time()
		smart.next_process_targets_time = math.random(2, 15)		-- default 1 to 10, changed to ease script load
	else
		return
	end
	
	if currently_surge then
		return
	end
	
	-- only check for night activity once per night per smart terrain
	local invading_faction_props = warfare_options.options.factions[smart.owning_faction]
	local night_chance = invading_faction_props.night_activity_chance
	local isNight = (level.get_time_hours() < 6 or level.get_time_hours() > 21)
	if isNight then
		if (night_activity_allowed[smart.id] == 0) then
			if (math.random(0,100) < night_chance) then
				night_activity_allowed[smart.id] = 1
			else
				night_activity_allowed[smart.id] = -1
			end
		end
	else
		night_activity_allowed[smart.id] = 0			-- reset for next night
	end
	
	-- if not cleared for night activity, don't proceed
	-- -1 for failed check, 0 for unchecked, 1 for cleared for night activity
	if (night_activity_allowed[smart.id] == -1) then
		return
	end
	
    printd(0, smart:name())

	if not (invading_faction_props and invading_faction_props.participate_in_warfare) then
		printd(1, smart:name())
		return
	end
	
	local aggression = invading_faction_props.expansion_aggression
	
	-- Make sure all targets are still valid and count them if they are (can't use # operator on hash tables)
	local target_smart_count = 0
	local auto_target_count = 0				-- used for target re-checking
	for target,v in pairs(smart.player_target_smarts) do
		local other = alife_object(target)
		
		if (other and other.owning_faction) then
			if (other.owning_faction ~= "none" and not is_factions_enemies(smart.owning_faction, other.owning_faction)) and (other.owning_faction ~= "stalker") and (other.owning_faction ~= "ecolog") then				-- enable targeting of loner-owned resources
				smart.player_target_smarts[other.id] = nil
				-- ceasefire check is equal to the current smart terrain owner if a ceasefire has been called in-between update cycles
				if (ceasefire_check[other.id] ~= other.owning_faction) then
					-- factions get upset when their targets are stolen from them
					faction_diplomatic_penalty(other.id, smart.owning_faction, other.owning_faction)
				end
				
			-- instantly send a squad to capture empty points or non-base loner/ecolog points
			elseif (other.owning_faction == "none") or (((other.owning_faction == "stalker") or (other.owning_faction == "ecolog")) and not is_factions_enemies(smart.owning_faction, other.owning_faction) and (other.props.base < 1)) then
				target_smart_count = target_smart_count + 1
				local numTargeting = squad_count(other, smart.owning_faction)
				local current_level = smart.level_id
				local isDaylight = (level.get_time_hours() > 5 and level.get_time_hours() < 22)
				-- send spare squad to empty targets if havent done so already, as long as manual control is off
				-- territories must be on-level, while bases/resources can be any
				if (numTargeting < 1) and isDaylight and ((other.props.resource > 0) or (other.props.base > 0) or (other.level_id == current_level)) and (math.random(100) < aggression) then
					capture_empty_location_simple(smart, other)
				end
			else
				target_smart_count = target_smart_count + 1
			end
		end
	end
	
	-- Make sure all targets are still valid and count them if they are (can't use # operator on hash tables)
	for target,v in pairs(smart.target_smarts) do
		local other = alife_object(target)
		
		if (other and other.owning_faction) then
			if (other.owning_faction ~= "none" and not is_factions_enemies(smart.owning_faction, other.owning_faction)) and (other.owning_faction ~= "stalker") and (other.owning_faction ~= "ecolog") then
				smart.target_smarts[other.id] = nil
				-- ceasefire check is equal to the current smart terrain owner if a ceasefire has been called in-between update cycles
				if (ceasefire_check[other.id] ~= other.owning_faction) then
					-- factions get upset when their targets are stolen from them
					faction_diplomatic_penalty(other.id, smart.owning_faction, other.owning_faction)
				end
				
			-- instantly send a squad to capture empty points or non-base loner/ecolog points
			elseif (other.owning_faction == "none") or (((other.owning_faction == "stalker") or (other.owning_faction == "ecolog")) and not is_factions_enemies(smart.owning_faction, other.owning_faction) and (other.props.base < 1)) then
				target_smart_count = target_smart_count + 1
				auto_target_count = auto_target_count + 1
				local numTargeting = squad_count(other, smart.owning_faction)
				local current_level = smart.level_id
				local isDaylight = (level.get_time_hours() > 5 and level.get_time_hours() < 22)
				-- send spare squad to empty targets if havent done so already, as long as manual control is off
				-- territories must be on-level, while bases/resources can be any
				if (numTargeting < 1) and isDaylight and ((other.props.resource > 0) or (other.props.base > 0) or (other.level_id == current_level)) and (math.random(100) < aggression) then
					capture_empty_location_simple(smart, other)
				end
			else
				target_smart_count = target_smart_count + 1
				auto_target_count = auto_target_count + 1
			end
		end
	end

	-- Make sure invasion is valid. If all squads are spawned, send them out.
	if (invasions[smart.id]) then
		local regular_squads,sq_pow,stationary_sq_num = squad_count_detailed(smart, smart.owning_faction)		-- get movable squads, stationary squads
		local guards = math.max(guard_size, stationary_sq_num)													-- number of squads to leave behind
		local targetID = invasions[smart.id][1]
		local target = targetID and alife_object(targetID)
		
		if not is_factions_enemies(smart.owning_faction, target.owning_faction) and (target.owning_faction ~= "stalker") and (target.owning_faction ~= "ecolog") then
			-- get new invasion target
			invasions[smart.id] = nil			-- reset
			target = get_invasion_target(smart)
			if (target) then
				create_invasion_plan(smart, target)
			end

			if not (invasions[smart.id]) then
				contribute_to_other_invasion(smart)
			end
		end

		-- check if time to send invasion out, then do so if ready
		if (invasions[smart.id]) and (target) then
			local invasion_size = invasions[smart.id][2]							-- desired number of squads for the invasion
			
			-- if population is enough, then send the invading force
			if (regular_squads + stationary_sq_num >= invasion_size + guards) then
				if not (invasions[smart.id][3]) then
					invasions[smart.id][3] = game.get_game_time()			-- get time to send invasion
				end

				local diff = game.get_game_time():diffSec(invasions[smart.id][3])
				local wait = invasions[smart.id][4] or 0

				if (diff > (wait * 60)) then
					-- check loner/ecolog target pop to see if invasion will grant control
					local loner_squads = squad_count_defending(target, target.owning_faction)
					local takeover_possible = false
					if not is_factions_enemies(smart.owning_faction, target.owning_faction) then 
						if (loner_squads < 2) then
							takeover_possible = true
						end
					else
						takeover_possible = true			-- invasions of hostile targets must be cleared
					end

					-- don't send out invasions during emissions or when under attack
					if takeover_possible and not under_attack[smart.id] then
						local numSent = 0
						local squads = SIMBOARD.smarts[smart.id].squads
						
						for sid,_ in pairs(squads) do
							local squad = sid and alife_object(sid)

							if squad_is_commandable(squad) and (squad:get_squad_community() == smart.owning_faction) and (squad.current_action == 1) then
								numSent = numSent + 1
								sim_squad_warfare.set_target(squad, target.id)
								
								-- stop sending squads once full force is sent
								if (numSent == invasion_size) then
									if enable_debug then
										printf("sending %s %s squads from %s to attack %s", invasion_size, smart.owning_faction, smart:name(), target:name())
									end
									break
								end
							end
						end
						
						-- inform actor, if on-level, about invasion
						if (warfare.actor_faction) and (warfare.actor_faction == smart.owning_faction) and (target.is_on_actor_level) then
							local icon = smart.owning_faction
							local smart_translated = translate_smart_name(smart:name()) or smart:name()
							local target_translated = translate_smart_name(target:name()) or target:name()
							local text = strformat(game.translate_string("st_wrfr_invasion_attack"), smart_translated, target_translated)
							--local text = "An allied attack force from "..smart_translated.." is launching an assault on "..target_translated.."."
							news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
						end
						
						-- end invasion targeting
						invasions[smart.id] = nil
					end
				end
			end
		end
	end
	
	-- add new targets to the base if needed
	if ((pda_actor.manual_control and smart.owning_faction ~= warfare.actor_faction) or (not pda_actor.manual_control)) then
		local targets = find_targets(smart)
			
		if (#targets > 0) then
			for i=1,#targets do
				if not (smart.target_smarts[targets[i][2]]) then
					local target_delta = target_smart_count - invading_faction_props.min_smart_targets_per_base
					if (target_delta < 0) then
						local other = alife_object(targets[i][2])
						local enemy_faction = other.owning_faction or "none"
						target_smart_count = target_smart_count + 1
						smart.target_smarts[targets[i][2]] = true
						ceasefire_check[targets[i][2]] = enemy_faction			-- target is hostile or empty
					elseif (target_smart_count < invading_faction_props.max_smart_targets_per_base) and (math.random(100) <= (aggression / (target_delta + 1))) then
						-- after getting minimum amount of targets, add more targets based on aggression. Subsequent bases beyond the minimum are more difficult to add
						local other = alife_object(targets[i][2])
						local enemy_faction = other.owning_faction or "none"
						target_smart_count = target_smart_count + 1
						smart.target_smarts[targets[i][2]] = true
						ceasefire_check[targets[i][2]] = enemy_faction			-- target is hostile or empty
						break													-- only add one extra target per update for targets beyond the minimum
					else
						break				-- not adding another target just yet
					end
				end
			end
		end
	end

	-- If the random number is less than or equal to the aggression for the faction, create a new invasion plan
	if (math.random(100) <= aggression) then	
		-- Choose a new invasion target if needed from the list of chosen targets.
		if not (invasions[smart.id]) then
			local target = get_invasion_target(smart)
			create_invasion_plan(smart, target)
		end
		
		-- if the invasion plan is not certified, very aggressive factions will instead look at nearby bases and see if they can contribute to their invasion
		if not (invasions[smart.id]) then
			contribute_to_other_invasion(smart)
		end
	end
	
	-- if the faction has lost a base or resource, re-check the targets for all bases
	local current_base_count = warfare_factions.faction_information[smart.owning_faction].base_count + warfare_options.options.factions[smart.owning_faction].base_count_modifier
	local current_resource_count = smart.resource_count
	if (auto_target_count > 0) and (current_base_count < base_recheck[smart.id]) or (current_resource_count < resource_recheck[smart.id]) then
		-- reset targets
		smart.target_smarts = {}
		target_smart_count = 0
		local targets = find_targets(smart)
		if (#targets > 0) then
			for i=1,#targets do
				if (target_smart_count < auto_target_count) then
					if not (smart.target_smarts[targets[i][2]]) then
						local other = alife_object(targets[i][2])
						local enemy_faction = other.owning_faction or "none"
						target_smart_count = target_smart_count + 1
						smart.target_smarts[targets[i][2]] = true
						ceasefire_check[targets[i][2]] = enemy_faction
					end
				end
			end
		end
		
		-- re-calculate the invasion plan
		if (invasions[smart.id]) then
			invasions[smart.id] = nil		-- discard current invasion plan
			local target = get_invasion_target(smart)
			create_invasion_plan(smart,target)			-- create new plan using new targets
			
			-- if the invasion plan is not certified, very aggressive factions will instead look at nearby bases and see if they can contribute to their invasion
			if not (invasions[smart.id]) then
				contribute_to_other_invasion(smart)
			end
		end
		
--		if enable_debug then
--			printf("re-checking targets/invasion of %s base %s due to loss of bases/resources: %s vs %s and %s vs %s", smart.owning_faction, smart:name(), current_base_count, base_recheck[smart.id], current_resource_count, resource_recheck[smart.id])
--		end
	end
	
	-- set new check numbers
	base_recheck[smart.id] = current_base_count
	resource_recheck[smart.id] = current_resource_count
	
    printd(2, smart:name())
end

function get_invasion_target(smart)
	printd(0, "get_invasion_target "..(not smart and "nil" or smart:name()))

	local target		
	
	for t,v in pairs(smart.player_target_smarts) do
		local other = alife_object(t)
		
		-- exclude empty terrains from invasions
		if other and not (other.owning_faction == "none") then
			local numTargeting = squad_count(other, smart.owning_faction)			-- number of invader squads targeting invaded location
			
			if (numTargeting < smart.max_population) then
				target = other
				break
			end
		end
	end
	
	if not (target) then
		for t,v in pairs(smart.target_smarts) do
			local other = alife_object(t)
		
			-- exclude empty terrains from invasions
			if other and not (other.owning_faction == "none") then
				local numTargeting = squad_count(other, smart.owning_faction)
				
				if (numTargeting < smart.max_population) then
					target = other
					break
				end
			end
		end
	end
	
	printd(1)

	return target
end


-- when an empty target is detected, the closest base to the target sends a squad to capture it.
function capture_empty_location(smart, target)
	
	-- disable this feature if manual control is turned on
	if (smart.owning_faction == warfare.actor_faction) and (pda_actor.manual_control) then
		return
	end

	local level = game_graph():vertex(target.m_game_vertex_id):level_id()
	local linked = level_targets.level_links[level]	
	local currentLevelSmarts = warfare_levels.level_information[level].smarts
	local smartCollection = {}
	local bases = {}

	-- accumulate smart terrains on-level and on linked levels
	for i=1,#currentLevelSmarts do
		smartCollection[#smartCollection+1] = currentLevelSmarts[i]
	end

	for lvl,_ in pairs(linked) do
		local smarts = warfare_levels.level_information[lvl].smarts
			
		for i=1,#smarts do
			smartCollection[#smartCollection+1] = smarts[i]
		end
	end

	-- search for the closest friendly bases to the target
	for i=1,#smartCollection do
		local other = smartCollection[i] and alife_object(smartCollection[i])		
		if (other and other.props and other.props.base > 0) and (other.owning_faction == smart.owning_faction) then
			local dist = fetch_smart_distance(other, target)
			-- accumulate candidate bases
			bases[#bases+1] = { dist, other.id }
		end
	end

	table.sort(bases, function(a, b)
		return math.abs(a[1]) < math.abs(b[1])
	end)

	for i=1,#bases do	
		local other = bases[i][2] and alife_object(bases[i][2])
		local shortest_dist = bases[1][1]
		local base_dist = bases[i][1]
		local regular_squads,sq_pow,stationary_sq_num = squad_count_detailed(other, other.owning_faction)
		local squads_available = regular_squads - math.max(guard_size, stationary_sq_num)
		
		-- bases that are more than 60% further away from the target compared to the closest base will not be considered - except the base that called this function (since it already has the target)
		-- only consider bases with spare squads that aren't under attack
		if ((smart.id == other.id) or (shortest_dist*1.6 < base_dist)) and (squads_available > 0) and not under_attack[other.id] then
			local ally_squads = SIMBOARD.smarts[other.id].squads
			
			for sid,_ in pairs(ally_squads) do
				local squad = sid and alife_object(sid)
				local faction = squad:get_squad_community()
				
				-- only check for idle squads of same faction
				if squad_is_commandable(squad) and (faction == other.owning_faction) and (squad.current_action == 1) then
					-- send the available squad
					sim_squad_warfare.set_target(squad, target.id)
					if enable_debug then
						printf("sending %s squad on base %s to empty terrain %s (requested by %s)", other.owning_faction, other:name(), target:name(), smart:name())
					end
					
					-- exit function
					return
				end
			end
		end
	end


--	if enable_debug then
--		printf("no %s bases within linked levels have spare squads to send to empty terrain %s", smart.owning_faction, target:name())
--	end
	
end


-- simple version of empty capture, with no regard for smart distances (remove computation of searching tables)
function capture_empty_location_simple(smart, target)

	-- disable this feature if manual control is turned on
	if (smart.owning_faction == warfare.actor_faction) and (pda_actor.manual_control) then
		return
	end

	local regular_squads,sq_pow,stationary_sq_num = squad_count_detailed(smart, smart.owning_faction)
	local squads_available = regular_squads - math.max(guard_size, stationary_sq_num)

	if (squads_available > 0) and not under_attack[smart.id] then
		local ally_squads = SIMBOARD.smarts[smart.id].squads
			
		for sid,_ in pairs(ally_squads) do
			local squad = sid and alife_object(sid)
			local faction = squad:get_squad_community()
			
			-- only check for idle squads of same faction
			if squad_is_commandable(squad) and (faction == smart.owning_faction) and (squad.current_action == 1) then
				-- send the available squad
				sim_squad_warfare.set_target(squad, target.id)
				if enable_debug then
					printf("sending %s squad on base %s to empty terrain %s", smart.owning_faction, smart:name(), target:name())
				end

				-- exit function
				return
			end
		end
	end

end


-- used to calculate the number of squads to send on an invasion
-- takes into account nearby enemy locations that could possibly reinforce the invasion target
-- also calculate the possibility for an immediate invasion with the current forces available vs the current enemy forces defending
function create_invasion_plan(smart, target)

	if not target then
		return
	end
	
	if not (target.owning_faction) then
		check_owner(target)
	end

	local invading_faction_props = warfare_options.options.factions[smart.owning_faction]
	local defending_faction = target.owning_faction
	local invasion_force_size
	local invasion_force_desired
	local invasion_force_immediate
	local immediate_invasion = false
	
	-- don't plan invasions of empty locations
	if (defending_faction == "none") then
		return
	end
	
	-- don't plan invasions of loner/ecolog resources
	if (target.props and target.props.base < 1) and not is_factions_enemies(defending_faction, smart.owning_faction) then
		return
	end
	
	-- non-enemies (i.e. loners/ecolog) only need to be invaded with 2 squads at the right moment
	if is_factions_enemies(defending_faction, smart.owning_faction) then
		
		-- get info of avg enemy squad power across all smarts within reach of the invasion target - need to do it this long way to include stationary squad powers
		local total_enemy_power = 0
		local num_enemy_squads = 0
		local enemy_target_squads = SIMBOARD.smarts[target.id].squads

		for sid,_ in pairs(enemy_target_squads) do
			local squad = sid and alife_object(sid)
			
			if (squad) and (squad.registered_with_warfare) and (squad:get_squad_community() == defending_faction) and not (warfare.ignore[squad:section_name()]) then
				total_enemy_power = total_enemy_power + sim_offline_combat.calculate_squad_power(squad)
				num_enemy_squads = num_enemy_squads + 1
			end
		end

		-- non-base targets only count the number of squads currently stationed
		local total_enemy_capacity
		if (target.props.base < 1) then
			total_enemy_capacity = num_enemy_squads
		else
			total_enemy_capacity = target.max_population
		end

		local total_enemy_capacity_immediate = num_enemy_squads

		-- scan target smart terrain's vicinity for other hostile locations
		local level_info = warfare_levels.level_information[target.level_id]
		for i,sm in pairs(level_info.smarts) do
			local other = sm and alife_object(sm)

			-- only consider occupied points with more than one squad on them, or bases that can potentially get more squads
			if (other.owning_faction == defending_faction) and (under_attack[other.id] == false) then
				local squadCount,squadPower = squad_count_defending(other, defending_faction)
				if (squadCount > 1) or (other.props.base > 0) then
					local reinforce_dist = fetch_smart_distance(target,other)
					local dist_to_target = fetch_smart_distance(smart,target)
					
					-- only consider their points close enough to help out, that are very close. EXCLUDE the target itself
					if ( reinforce_dist < (0.4*dist_to_target) ) and (other.id ~= target.id) then
						if (other.props.base > 0) then
							total_enemy_capacity = total_enemy_capacity + other.max_population - guard_size
							total_enemy_capacity_immediate = total_enemy_capacity_immediate + squadCount - guard_size
						else
							total_enemy_capacity = total_enemy_capacity + 0.5 * other.max_population					-- non-bases don't add as much to the reinforcement threat
							total_enemy_capacity_immediate = total_enemy_capacity_immediate + squadCount
						end
						
						num_enemy_squads = num_enemy_squads + squadCount
						total_enemy_power = total_enemy_power + squadPower
					end
				end
			end
		end
	
		-- get allied squad avg power
		local num_allied_squads = 0
		local total_allied_power = 0
		local level_info = warfare_levels.level_information[smart.level_id]
		for i,sm in pairs(level_info.smarts) do
			local other = sm and alife_object(sm)
			if (other.owning_faction == smart.owning_faction) then
				local sq_num, sq_pow = squad_count_detailed(other, smart.owning_faction)
				num_allied_squads = num_allied_squads + sq_num
				total_allied_power = total_allied_power + sq_pow
			end
		end
		
		-- compare average enemy squad power to the attacking faction's average squad power
		local avg_allied_squad_power = total_allied_power / num_allied_squads
		local avg_enemy_squad_power = total_enemy_power / num_enemy_squads
		local power_ratio = avg_enemy_squad_power / avg_allied_squad_power		-- how many times more powerful are enemy squads than allied squads
		
		local sq_num,sq_pow,sq_stat = squad_count_detailed(smart, smart.owning_faction)
		local origin_base_max_force = 2 * smart.max_population - sq_stat					-- set a hard limit on max size of invasion force, only 2x the max pop of the origin base (minus any stationary squads present)
		local x = math.random()
		local invasion_size_factor = warfare.lerp( invading_faction_props.min_invasion_size, invading_faction_props.max_invasion_size, x )			-- linear interpolation of random between min and max factors
		
		-- calculate desired number of squads
		invasion_force_desired = math.max(1, round_idp( total_enemy_capacity * invasion_size_factor * power_ratio ))					-- how many squads to send assuming the target base and reinforcing bases will be at capacity
		invasion_force_immediate = math.max(1, round_idp( total_enemy_capacity_immediate * invasion_size_factor * power_ratio ))		-- how many squads to send RIGHT NOW based on the enemy's current defense RIGHT NOW
		
		-- if the invading base is capable of sending a successful invasion instantly, it will do so
		local current_available_force = sq_num - math.max(guard_size, sq_stat)
		if (invasion_force_immediate <= current_available_force) then
			immediate_invasion = true
			invasion_force_size = invasion_force_immediate
		else
			invasion_force_size = math.min(origin_base_max_force, invasion_force_desired)
		end

	else
		local sq_num,sq_pow,sq_stat = squad_count_detailed(smart, smart.owning_faction)
		local overtake_size = math.max(guard_size, sq_stat) + 1					-- this is typically equal to 2, so only need 2 squads to overtake. Places with multiple stationary squads may need more
		invasion_force_desired = overtake_size
		invasion_force_size = overtake_size
	end

	-- set invasion
	local inv_start = nil
	local min_depart = invading_faction_props.min_invasion_depart_time
	local max_depart = invading_faction_props.max_invasion_depart_time
	local depart = 0
	if not immediate_invasion then
		depart = math.random(min_depart, max_depart)
	end
	
	-- invasion will be planned if the possible force is within reason
	if ( (invasion_force_size > 0) and (invasion_force_desired / invasion_force_size) < 2 ) or (immediate_invasion) then
		invasions[smart.id] = { target.id, invasion_force_size, inv_start, depart }
		
--		if enable_debug then
--			if immediate_invasion then
--				printf("prepping instant invasion from %s base %s to target %s with force of %s squads", smart.owning_faction, smart:name(), target:name(), invasion_force_size)
--			else
--				printf("planning invasion from %s base %s to target %s with force of %s squads (desired was %s)", smart.owning_faction, smart:name(), target:name(), invasion_force_size, invasion_force_desired)
--			end
--		end
	end
end



-- if an invasion plan is not certified, very aggressive factions will instead look at nearby bases on-level and see if they can contribute to their invasion
function contribute_to_other_invasion(smart)
	
	-- disable this feature if manual control is turned on
	if (smart.owning_faction == warfare.actor_faction) and (pda_actor.manual_control) then
		return
	end
	
	local regular_squads,sq_pow,stationary_sq_num = squad_count_detailed(smart, smart.owning_faction)
	local squads_available = regular_squads - math.max(guard_size, stationary_sq_num)
	local aggression = warfare_options.options.factions[smart.owning_faction].expansion_aggression
	
	if (squads_available > 0) and (math.random(100) <= aggression) and not under_attack[smart.id] then
		local level_info = warfare_levels.level_information[smart.level_id]
		local ally_locations = {}

		for i,sm in pairs(level_info.smarts) do												-- loop over all on-level smart terrains
			local other = sm and alife_object(sm)

			-- only consider points with active invasion plans
			if (other.owning_faction == smart.owning_faction) and (invasions[other.id]) then
				local invasion_target = invasions[other.id][1] and alife_object(invasions[other.id][1])
				local enemy_target_dist = fetch_smart_distance(other, invasion_target)
				local reinforce_dist = fetch_smart_distance(smart,other)
				local other_sq_reg,pow,sq_stat = squad_count_detailed(other, other.owning_faction)
				local squads_needed = invasions[other.id][2] + math.max(guard_size, sq_stat) - other_sq_reg - sq_stat
				
				-- only consider points that are very close compared to the invasion target distance, that still need squads. Invasions which are closest to reaching their target size get priority
				if ( reinforce_dist < (0.3*enemy_target_dist) ) and (squads_needed > 0) then
					ally_locations[#ally_locations+1] = { squads_needed * reinforce_dist * reinforce_dist, other.id }
				end
			end
		end
		
		table.sort(ally_locations, function(a, b)
			return math.abs(a[1]) < math.abs(b[1])
		end)
	
		if (#ally_locations > 0) then
			for i=1,#ally_locations do	
				local other = ally_locations[i][2] and alife_object(ally_locations[i][2])
				
				if (other and other.owning_faction) then
					local squads = SIMBOARD.smarts[smart.id].squads
					for sid,_ in pairs(squads) do
						local squad = sid and alife_object(sid)
						if (squads_available > 0) and squad_is_commandable(squad) and (squad:get_squad_community() == smart.owning_faction) and (squad.current_action == 1) then
							sim_squad_warfare.set_target(squad, other.id)
							squads_available = squads_available - 1
							if enable_debug then
								printf("giving one %s squad at %s to invasion force prepping at %s", smart.owning_faction, smart:name(), other:name())
							end
						end
					end
				end
			end
		end
	end

end



-- used to determine if an invasion is heading towards a given occupied point
-- If the invading force has a higher total squad power, request reinforcements from the nearest on-level locations (that are secure)
function process_invasion_defense(smart)

	if not (invasion_defense_timers[smart.id]) then
		invasion_defense_timers[smart.id] = game.get_game_time()
		invasion_defense_next_update[smart.id] = math.random(3, 12)
		under_attack[smart.id] = false					-- initialize
		reinforcements_requested[smart.id] = false		-- initialize
		actor_informed[smart.id] = false				-- initialize
		return
	end

	if (game.get_game_time():diffSec(invasion_defense_timers[smart.id]) >= invasion_defense_next_update[smart.id]*60) then
		invasion_defense_timers[smart.id] = game.get_game_time()
		invasion_defense_next_update[smart.id] = math.random(3, 12)
	else
		return
	end

	if currently_surge then
		return
	end

	if not smart.owning_faction then
		check_owner(smart)
	end

	-- only bases and resources can request reinforcements
	if (smart.props) and (smart.props.base < 1 and smart.props.resource < 1) then
		return
	end

	-- get faction of this smart terrain
	local defending_faction = smart.owning_faction
	local defending_faction_defense_factor = warfare_options.options.factions[smart.owning_faction].max_invasion_size
	
	-- don't use this function if manual faction control is enabled
	if (defending_faction == warfare.actor_faction) and (pda_actor.manual_control) then
		return
	end
	
	-- factions below cannot make use of this function
	if (defending_faction == "none") or (defending_faction == "monster") or (defending_faction == "zombied") or (defending_faction == "stalker") or (defending_faction == "ecolog") then
		under_attack[smart.id] = false
		reinforcements_requested[smart.id] = false
		return
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
	local total_enemy_power = 0
	local num_enemy_squads = 0
	local total_allied_power = 0
	local enemy_distance = 0
	local msg_allied_squad		-- store an allied squad for message ID purposes
	-- determine all enemy squads advancing on this position
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		
		-- don't include ignore_list squads or story squads
		-- also exclude random patrols
		if (squad) and (squad.registered_with_warfare) and (not warfare.ignore[squad:section_name()]) and (not random_patrols[squad.id]) then
			local faction = squad:get_squad_community()

			-- count all enemy squads in transit, find their distances to the smart, and their squad powers
			if is_factions_enemies(faction,defending_faction) and (squad.current_action == 0) then
				total_enemy_power = total_enemy_power + sim_offline_combat.calculate_squad_power(squad)				-- sum up squad powers
				num_enemy_squads = num_enemy_squads + 1
				enemy_distance = enemy_distance + warfare.distance_to_xz_sqr(global_position.from(smart), global_position.from(squad))
			-- count allied squads at point (or in transit) and their squad powers
			elseif (faction == defending_faction) then
				total_allied_power = total_allied_power + sim_offline_combat.calculate_squad_power(squad)
				msg_allied_squad = squad
			end
		end
	end
	
	-- if no enemy squads targeting, reset variables and exit function
	if (num_enemy_squads == 0) then
		
		-- if the terrain is no longer in danger, inform the actor if they were partaking in the defense
		if (under_attack[smart.id] == true) and (warfare.actor_faction == defending_faction) and (smart.is_on_actor_level) and (actor_informed[smart.id]) and msg_allied_squad then
			local sender
			for guy in msg_allied_squad:squad_members() do
				local person = guy.object or guy.id and alife():object(guy.id)
				if person then
					sender = person
					break
				elseif guy then
					sender = guy
					break
				end
			end
			
			local sender_header = strformat("%s, %s", sender:character_name(), game.translate_string("st_dyn_news_comm_" .. warfare.actor_faction .. "_" .. 6))
			local smart_translated = translate_smart_name(smart:name()) or smart:name()
			local rnd_clear = round_idp(math.random()*4)+1
			local msg = strformat(game.translate_string("st_wrfr_invasion_defense_clear_"..rnd_clear), smart_translated)		-- get a random string and then add the correct smart name
			dynamic_news_helper.send_tip( msg, sender_header, 0, 10, sender:character_icon(), "beep_1", "npc" )

			--local icon = "completionist"
			--local text = "Enemy forces targeting "..smart_translated.." have been eliminated."
			--news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
		end
		
		under_attack[smart.id] = false
		actor_informed[smart.id] = false
		reinforcements_requested[smart.id] = false
		return
	end

	-- if the function has gotten to this point, the smart is under attack
	under_attack[smart.id] = true
	local avg_enemy_dist = enemy_distance / num_enemy_squads			-- find average distance to enemy
	
	-- Loners/ecologs evacuate the point
	loners_next_update[smart.id] = math.random(1, 10)		-- loners may stick around longer
	ecolog_next_update[smart.id] = math.random(1, 3)		-- ecologists always leave
	
	-- if reinforcements have already been requested, don't keep looking for more
	if (reinforcements_requested[smart.id] == true) then
		
		-- if part of actor's faction and actor is on level, send them a message about the attack/reinforcements if they havent received one
		if (warfare.actor_faction) and (warfare.actor_faction == defending_faction) and (smart.is_on_actor_level) and (1.5*smart.dist_to_actor < avg_enemy_dist) and (not actor_informed[smart.id]) then
			local icon = "patriarch"
			local smart_translated = translate_smart_name(smart:name()) or smart:name()
			local text = strformat(game.translate_string("st_wrfr_invasion_defense_incoming"), smart_translated)
			--local text = "Enemy forces are approaching "..smart_translated.."."
			news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
			actor_informed[smart.id] = true
		end
		
		return
	end

	-- if allied squad power is way above enemy squad power, then no need to call for reinforcements
	if ( total_allied_power > (total_enemy_power*defending_faction_defense_factor) ) then
		return
	end

	-- need to call reinforcements - check power disparity
	reinforcements_requested[smart.id] = true
	local power_disparity = (total_enemy_power*defending_faction_defense_factor) - total_allied_power

	-- search for bases on-level that are closer than the average enemy distance
	local level_info = warfare_levels.level_information[smart.level_id]
	local ally_locations = {}

	for i,sm in pairs(level_info.smarts) do												-- loop over all on-level smart terrains
		local other = sm and alife_object(sm)

		-- only consider occupied points with enough squads on them, that also aren't under attack
		if (other.owning_faction == defending_faction) and (under_attack[other.id] == false) then
			local reinforce_dist = fetch_smart_distance(smart,other)

			-- only consider points close enough to help out, want the locations to be slightly closer than the squad
			if ( reinforce_dist < (0.8*avg_enemy_dist) ) then
				ally_locations[#ally_locations+1] = { reinforce_dist, other.id }
			end
		end
	end
	
	table.sort(ally_locations, function(a, b)
		return math.abs(a[1]) < math.abs(b[1])
	end)

	local squads_sent = false

	-- if any allies are nearby, send squads starting from the closest places
	if (#ally_locations > 0) then
		for i=1,#ally_locations do	
			local other = ally_locations[i][2] and alife_object(ally_locations[i][2])
			
			if (other and other.owning_faction) then
				local regular_squads,sq_pow,stationary_sq_num = squad_count_detailed(other,defending_faction)
				local ally_squads = SIMBOARD.smarts[other.id].squads
				local squads_available = 0
				
				-- bases and resources need to keep at least one squad on them. territories can send all squads
				if (other.props.base > 0 or other.props.resource > 0) then
					squads_available = regular_squads - math.max(guard_size, stationary_sq_num)
				elseif (other.props.base < 1 and other.props.resource < 1) then
					squads_available = regular_squads - stationary_sq_num
				end

				if (squads_available > 0) then
					for sid,_ in pairs(ally_squads) do
						local squad = sid and alife_object(sid)
						local faction = squad:get_squad_community()
						
						-- only check for idle squads of same faction
						if squad_is_commandable(squad) and (faction == defending_faction) and (squad.current_action == 1) and (squads_available > 0) then
							-- send the available squad and re-calculate the power disparity
							local ally_squad_power = sim_offline_combat.calculate_squad_power(squad)
							sim_squad_warfare.set_target(squad, smart.id)
							squads_available = squads_available - 1
							power_disparity = power_disparity - ally_squad_power
							squads_sent = true
							if enable_debug then
								printf("sending %s reinforcement squad from %s to location under attack %s", defending_faction, other:name(), smart:name())
							end
							if (power_disparity < 0) then
								return				-- once power disparity is made up, stop sending squads
							end
						end
					end
				end
			end
		end
		
		-- not enough reinforcements were available to make up the power disparity
		if enable_debug then
			if squads_sent then
				printf("not enough %s reinforcements were available in the vicinity to sufficiently assist %s", defending_faction, smart:name())
			else
				printf("no %s reinforcements were available in the area to assist %s", defending_faction, smart:name())
			end
		end

		-- if part of actor's faction and actor is on level, send them a message about the attack/reinforcements
		if (warfare.actor_faction) and (warfare.actor_faction == defending_faction) and (smart.is_on_actor_level) and (1.5*smart.dist_to_actor < avg_enemy_dist) then
			if (power_disparity < 0) then
				local icon = "completionist"
				local smart_translated = translate_smart_name(smart:name()) or smart:name()
				local text = strformat(game.translate_string("st_wrfr_invasion_defense_fullyreinforced"), smart_translated)
				--local text = "Enemy forces are approaching "..smart_translated..". Reinforcements have been sent."
				news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
				actor_informed[smart.id] = true
			else
				if squads_sent then
					local icon = "patriarch"
					local smart_translated = translate_smart_name(smart:name()) or smart:name()
					local text = strformat(game.translate_string("st_wrfr_invasion_defense_partlyreinforced"), smart_translated)
					--local text = "Enemy forces are approaching "..smart_translated..". More reinforcements are needed!"
					news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
					actor_informed[smart.id] = true
				else
					local icon = "patriarch"
					local smart_translated = translate_smart_name(smart:name()) or smart:name()
					local text = strformat(game.translate_string("st_wrfr_invasion_defense_notreinforced"), smart_translated)
					--local text = "Enemy forces are approaching "..smart_translated..". Reinforcements needed!"
					news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
					actor_informed[smart.id] = true
				end
			end
		end
	else
		-- if function has gotten to this point, then no reinforcements were in the vicinity
		if enable_debug then
			printf("no %s reinforcements were available in the area to assist %s", defending_faction, smart:name())
		end
		
		if (warfare.actor_faction) and (warfare.actor_faction == defending_faction) and (smart.is_on_actor_level) and (1.5*smart.dist_to_actor < avg_enemy_dist) then
			local icon = "patriarch"
			local smart_translated = translate_smart_name(smart:name()) or smart:name()
			local text = strformat(game.translate_string("st_wrfr_invasion_defense_notreinforced"), smart_translated)
			--local text = "Enemy forces are approaching "..smart_translated..". Reinforcements needed!"
			news_manager.send_tip( db.actor, text, nil, icon, nil, nil )
			actor_informed[smart.id] = true
		end
	end
	
end




function update_resources(smart)	
	if not (smart.resource_timer) or game.get_game_time():diffSec(smart.resource_timer) > (smart.resource_next_update*60) then
		smart.resource_timer = game.get_game_time()
		smart.resource_next_update = 5
	else
		return
	end

	if (warfare_factions.faction_information and warfare_factions.faction_information[smart.owning_faction]) then
		local global_resources = warfare_factions.faction_information[smart.owning_faction].resource_count
		local levelID = game_graph():vertex(smart.m_game_vertex_id):level_id()
		local modifier = warfare_options.options.factions[smart.owning_faction].resource_count_modifier
		local regional_resources = warfare_levels.level_information[levelID] and warfare_levels.level_information[levelID].faction_stats and warfare_levels.level_information[levelID].faction_stats[smart.owning_faction] and warfare_levels.level_information[levelID].faction_stats[smart.owning_faction].linked_resource_count or 0
		local local_resources = warfare_levels.level_information[levelID] and warfare_levels.level_information[levelID].faction_stats and warfare_levels.level_information[levelID].faction_stats[smart.owning_faction] and warfare_levels.level_information[levelID].faction_stats[smart.owning_faction].resource_count or 0
		local total_resources = global_resources -- + (regional_resources * 2) + (local_resources * 3)	
		smart.resource_count = total_resources + modifier
	else
		smart.resource_count = 0
		warfare_factions.update_faction(smart.owning_faction)
	end
end

function spawn_defense(smart)
	local faction_bases
	if not (defense_timers[smart.id]) or reset_defense_timer[smart.id] then
		local min_respawn = warfare_options.options.factions[smart.owning_faction].min_faction_respawn
		local max_respawn = warfare_options.options.factions[smart.owning_faction].max_faction_respawn
		faction_bases = warfare_factions.faction_information[smart.owning_faction].base_count + warfare_options.options.factions[smart.owning_faction].base_count_modifier									-- base count plus modifier
		local current_respawn = warfare.lerp(min_respawn, max_respawn, clamp(faction_bases / warfare.base_count, 0, 1))
		defense_next_update[smart.id] = current_respawn
		defense_timers[smart.id] = game.get_game_time()
		reset_defense_timer[smart.id] = nil											-- timer reset only occurs when a base changes owners
		return
	elseif (game.get_game_time():diffSec(defense_timers[smart.id]) > (defense_next_update[smart.id]*60)) then
		local min_respawn = warfare_options.options.factions[smart.owning_faction].min_faction_respawn
		local max_respawn = warfare_options.options.factions[smart.owning_faction].max_faction_respawn
		faction_bases = warfare_factions.faction_information[smart.owning_faction].base_count + warfare_options.options.factions[smart.owning_faction].base_count_modifier
		local current_respawn = warfare.lerp(min_respawn, max_respawn, clamp(faction_bases / warfare.base_count, 0, 1))
		defense_next_update[smart.id] = current_respawn
		defense_timers[smart.id] = game.get_game_time()
	else
		--printf("not ready to spawn squad at " .. smart:name() .. " more time needed: " .. game.get_game_time():diffSec(defense_timers[smart.id]) .. " out of " .. (defense_next_update[smart.id]*60))
		return
	end
	
	printd(0, smart:name())
		
	if (is_factions_enemies(smart.owning_faction, warfare.actor_faction) and smart.is_on_actor_level and smart.dist_to_actor) then 
		if (smart.dist_to_actor < smart.respawn_radius) then
			printd(1, smart:name())
			return
		end
	end	
	
	--local current = squad_count(smart, smart.owning_faction)
	--local size = invasions[smart.id] and invasions[smart.id][2] or 0
	--local totalSize = size + smart.max_population
	
	
	local section = faction_expansions.get_spawn_section(smart.owning_faction, smart.resource_count)
	
	-- army spawn quality depends on number of bases
	if (warfare_options.options.factions[smart.owning_faction].use_bases_not_resources) then
		section = faction_expansions.get_spawn_section(smart.owning_faction, faction_bases)
	end
	
	local squad = utils_obj.create_squad(section, smart:name())
	sim_squad_warfare.set_target(squad, smart.id)		
	
	printd(2, smart:name())
end

-- unused function
function process_defense(smart)
	-- TODO: interpolate between min and max respawn times (make two different sets of variables for defense and offense?)
	if not (smart.process_defense_timer) or (game.get_game_time():diffSec(smart.process_defense_timer) > (smart.next_process_defense_update*60)) then
		smart.process_defense_timer = game.get_game_time()
		smart.next_process_defense_update = math.random(2, 10)
	else
		return
	end
end

function spawn_patrols(smart)					
	printd(0, smart:name())

	if not (patrol_timers[smart.id]) then
		patrol_timers[smart.id] = game.get_game_time()
		patrol_next_update[smart.id] = 10

		if (smart.owning_faction ~= "none") then
        	local ff = warfare_options.options.factions[smart.owning_faction]
			local faction_bases = warfare_factions.faction_information[smart.owning_faction].base_count + warfare_options.options.factions[smart.owning_faction].base_count_modifier
			local respawn
			
			if (ff) then
				respawn = warfare.lerp(ff.min_patrol_time, ff.max_patrol_time, clamp(faction_bases / warfare.base_count, 0, 1))
			else
				respawn = 10
			end

			patrol_next_update[smart.id] = respawn
		end

		return
	elseif (game.get_game_time():diffSec(patrol_timers[smart.id]) > (patrol_next_update[smart.id]*60)) then
		patrol_timers[smart.id] = game.get_game_time()
		patrol_next_update[smart.id] = 10

		if (smart.owning_faction ~= "none") then
        	local ff = warfare_options.options.factions[smart.owning_faction]
			local faction_bases = warfare_factions.faction_information[smart.owning_faction].base_count + warfare_options.options.factions[smart.owning_faction].base_count_modifier
			local respawn
			
			if (ff) then
				respawn = warfare.lerp(ff.min_patrol_time, ff.max_patrol_time, clamp(faction_bases / warfare.base_count, 0, 1))
			else
				respawn = 10
			end
			
			patrol_next_update[smart.id] = respawn
		end
	else
		return
	end
					
	local squads = patrol_squads[smart.id]
	local count = 0

	for squad_id, sobj in pairs(squads) do
		count = count + 1
	end

	local patrol_pop = warfare_factions.faction_information[smart.owning_faction].patrol_pop_factor

	if (count < patrol_pop) then
	
		if is_factions_enemies(smart.owning_faction, warfare.actor_faction) and (smart.is_on_actor_level and smart.dist_to_actor ~= nil) then 
			if (smart.dist_to_actor < smart.respawn_radius) then
				printd(1, smart:name())
				return
			end
		end
	
		local night_chance = warfare_options.options.factions[smart.owning_faction].night_activity_chance
		local isNight = (level.get_time_hours() < 6 or level.get_time_hours() > 20)

		if (isNight and math.random(100) <= night_chance or not isNight) then
			local tobj,is_squad = find_patrol_target(smart)							
			local new_table = nil

			if (tobj) then
				local section = faction_expansions.get_spawn_section(smart.owning_faction, smart.resource_count)
				local squad = utils_obj.create_squad(section, smart:name())

				if (is_squad) then
					new_table = {
						target = tobj.id,
						attacking = true,
						stay_time = nil,
						arrive_time = nil
					}
				else
					new_table = {
						target = tobj.id,
						stay_time = nil,
						arrive_time = nil
					}
				end
				
				sim_squad_warfare.set_target(squad, tobj.id)
				patrol_squads[smart.id][squad.id] = new_table
				squad.patrol_table = new_table
			end
		end
	end
	
	local count = 0
	for squad_id, sobj in pairs(squads) do		
		count = count + 1
	end
end

function find_patrol_target(smart,patrol_table,squad)
	printd(0, "find_patrol_target - smart: "..(not smart and "nil" or smart:name()).."squad: "..(not squad and "nil" or squad:name()))

	local target_squads = {}
	local target_smarts = {}
	local smarts_by_distance = {}	
	local squads = patrol_squads[smart.id]
	
	if not (smart.owning_faction) then
		check_owner(smart)
	end
	
	if (smart.owning_faction == "none") then
		return
	end
	
	local patrol_pop = warfare_factions.faction_information[smart.owning_faction].patrol_pop_factor
	
	local curr_level_id = smart.level_id
	local curr_level_smarts = warfare_levels.level_information[curr_level_id].smarts

	for _,neighbor_id in pairs(curr_level_smarts) do
		local neighbor = neighbor_id and alife_object(neighbor_id)

		if (neighbor) then
			if (neighbor.props and ((neighbor.props.territory > 0 or neighbor.props.lair > 0) and neighbor.props.resource < 1 and neighbor.props.base < 1)) then
				local dist = warfare.distance_to_xz_sqr(global_position.from(smart), global_position.from(neighbor))

				if (not patrol_table or patrol_table[1] ~= neighbor_id) then
					smarts_by_distance[#smarts_by_distance + 1] = { neighbor, dist }
				end
			end
		end
	end

	table.sort(smarts_by_distance, function(a, b)
		return a[2] < b[2]
	end)

	for j=1,patrol_pop*2 do
		if (#smarts_by_distance > j) then
			target_smarts[#target_smarts+1] = smarts_by_distance[j][1]
		end
	end

	if (smart.target_smarts) then
		target_smarts = {}

		for target,_ in pairs(smart.target_smarts) do
			local other = target and alife_object(target)			
			local level_id = smart.level_id
			local level_smarts = warfare_levels.level_information[level_id].smarts
			local found_target = false
			smarts_by_distance = {}

			for _,neighbor_id in pairs(level_smarts) do
				local neighbor = neighbor_id and alife_object(neighbor_id)

				if (neighbor) then
					if (neighbor.props and ((neighbor.props.territory > 0 or neighbor.props.lair > 0) and neighbor.props.resource < 1 and neighbor.props.base < 1)) then
						local dist = warfare.distance_to_xz_sqr(global_position.from(smart), global_position.from(neighbor))

						if (not patrol_table or patrol_table[1] ~= neighbor_id) then
							smarts_by_distance[#smarts_by_distance + 1] = { neighbor, dist }
						end
					end
				end	
			end

			table.sort(smarts_by_distance, function(a, b)
				return a[2] < b[2]
			end)

			for j=1,patrol_pop*2 do
				if (#smarts_by_distance > j) then
					target_smarts[#target_smarts+1] = smarts_by_distance[j][1]
				end
			end

			if (other.props and other.props.base > 0) then			
				local squads2 = patrol_squads[target]

				if (squads2) then
					for patrol_id,obj in pairs(squads2) do
						local other_patrol = patrol_id and alife_object(patrol_id)

						if (other_patrol) then
							if (other_patrol:clsid() == clsid.online_offline_group_s) then
								if (is_factions_enemies(other_patrol:get_squad_community(), squad and squad:get_squad_community() or smart.owning_faction)) then
									target_squads[#target_squads+1] = other_patrol
								end
							end
						end
					end
				end
			end
		end
	end

	local hunt_chance = warfare_options.options.factions[smart.owning_faction].patrol_hunt_chance or 50
							
	printd(1)

	if (#target_squads > 0 and hunt_chance >= math.random(100)) then
		return target_squads[math.random(#target_squads)],true
	elseif (#target_smarts > 0) then
		return target_smarts[math.random(#target_smarts)],false
	end

	return nil,false
end

function process_patrols(smart)
	-- TODO: interpolate between min and max respawn times (make two different sets of variables for defense and offense?)
	if not (smart.process_patrols_timer) then
		smart.process_patrols_timer = game.get_game_time()
		smart.next_process_patrols_update = math.random(2, 10)
		return
	end

	if (game.get_game_time():diffSec(smart.process_patrols_timer) > (smart.next_process_patrols_update*60)) then
		smart.process_patrols_timer = game.get_game_time()
		smart.next_process_patrols_update = math.random(2, 10)
	else
		return
	end
	
	local squads = patrol_squads[smart.id]

	for squad_id, sobj in pairs(squads) do
		local squad = squad_id and alife_object(squad_id)
		
		if (squad and squad:clsid() == clsid.online_offline_group_s) and (not warfare.ignore[squad:section_name()]) and (not sim_offline_combat.stationary_squads[squad:section_name()]) then
			squad.patrol_owner = smart.id
			squad.patrol_table = patrol_squads[smart.id][squad_id]

			if (squad:npc_count() == 0) then
				patrol_squads[smart.id][squad_id] = nil
			elseif not (squad.get_squad_community and squad:get_squad_community() == smart.owning_faction) then
				patrol_squads[smart.id][squad_id] = nil
			else
				squad.patrol_owner = smart.id
				local find_target = false				
				local other = sobj.target and alife_object(sobj.target)			
				local level_id = smart.level_id
				local level_smarts = warfare_levels.level_information[level_id].smarts

				if not (other and squad.current_target_id) then
					find_target = true
				end

				if (sobj.attacking) then					
					local found = false

					for _,other_id in pairs(level_smarts) do
						local squads2 = patrol_squads[other_id]

						if (squads2) then
							for patrol_id,obj in pairs(squads2) do
								if (patrol_id == sobj.target) then
									found = true
									break
								end
							end
						end

						if (found) then
							break
						end 
					end

					if not (found) then
						find_target = true
					end
				end

				if (find_target or squad.current_action == 1) then
					if (not find_target and not (sobj.attacking or sobj.arrive_time)) then
						patrol_squads[smart.id][squad_id].arrive_time = game.get_game_time()					
						local min_idle = warfare_options.options.factions[squad:get_squad_community()].min_patrol_rest_time or 0
						local max_idle = warfare_options.options.factions[squad:get_squad_community()].max_patrol_rest_time	or 0
						patrol_squads[smart.id][squad_id].stay_time = math.random(min_idle, max_idle)
					elseif (find_target or game.get_game_time():diffSec(sobj.arrive_time) >= (sobj.stay_time*60)) then
						local night_chance = warfare_options.options.factions[smart.owning_faction].night_activity_chance
						local isNight = (level.get_time_hours() < 6 or level.get_time_hours() > 20)

						if (isNight and math.random(100) <= night_chance or not isNight) then
							local tobj,is_squad = find_patrol_target(smart, sobj, squad)
							local new_table = nil

							if (tobj) then
								if (is_squad) then
									new_table = {
										target = tobj.id,
										attacking = true,
										stay_time = nil,
										arrive_time = nil
									}
								else
									new_table = {
										target = tobj.id,
										stay_time = nil,
										arrive_time = nil
									}
								end
								
								sim_squad_warfare.set_target(squad, tobj.id)
								patrol_squads[smart.id][squad.id] = new_table
								squad.patrol_table = new_table
							end
						end
					end	
				end
			end
		else
			patrol_squads[smart.id][squad_id] = nil
		end
	end
end


-- Code to handle loner behavior, including targeting of locations, travel to and from those points, etc.
function process_loners(smart)
	
	if not (loner_timer[smart.id]) then
		loner_timer[smart.id] = game.get_game_time()
		loners_next_update[smart.id] = math.random(30, 90)				-- time in in-game minutes. Each min is 10 seconds real time. This will function as the squad 'wait time' for now
		return
	end

	if (game.get_game_time():diffSec(loner_timer[smart.id]) >= loners_next_update[smart.id]*60) and not currently_surge then
		loner_timer[smart.id] = game.get_game_time()
		loners_next_update[smart.id] = math.random(30, 90)
	else
		return
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads							-- get info of all squads at location

	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		local faction = squad:get_squad_community()							-- get faction of squads
		
		if (faction == "stalker") and squad_is_commandable(squad, true) and (squad.current_action == 1) then								-- only operate on loners, exclude unique npcs
			local night_chance = warfare_options.options.factions[faction].night_activity_chance
			local isNight = (level.get_time_hours() < 6 or level.get_time_hours() > 20)
			local isDaylight = (level.get_time_hours() > 6 and level.get_time_hours() < 17)
			local isSunset = (level.get_time_hours() > 18 and level.get_time_hours() < 21)
			
			local target_set = false
			local all_targets = {}
			local priority_targets = {}

			if (smart.props and smart.props.base > 0) and (isDaylight) and (math.random(1,10) < 9) then												-- updates squads at a base. Squads are assigned to resource locations during daylight hours. 10% chance that they're lazy bums and sit at base until the next update
				if ((smart.owning_faction ~= "stalker") or (smart.owning_faction == "stalker" and squad_count(smart, "stalker") > 1)) then				-- Loner-owned bases keep their last squad to retain control
					if (math.random(1, 10) < 7) then																									-- 70% chance of staying on-level
						if (math.random(1,20) < 19) then																								-- 5% chance for an on-level squad to be mutant hunters, going to lairs instead
							local level_info = warfare_levels.level_information[smart.level_id]
							
							for i,sm in pairs(level_info.smarts) do																							-- loop over all on-level smart terrains
								local other = sm and alife_object(sm)
							
								if not (other.owning_faction) then
									check_owner(other)
								end
								
								if (other.props and other.props.resource > 0) then 
									if (other.owning_faction == "none") then																		-- target resources with no stalkers already present
										all_targets[#all_targets+1] = other																						-- add possible locations to list of targets
									elseif (is_factions_enemies("stalker", other.owning_faction)) then
										-- loners will attack enemy positions if they are much stronger than the enemies, chance to attack scales with the power disparity
										local enemy_squads = SIMBOARD.smarts[other.id].squads
										local enemy_power = 0
										local loner_power = sim_offline_combat.calculate_squad_power(squad)
										for enemy_id,_ in pairs(enemy_squads) do
											local enemy_squad = enemy_id and alife_object(enemy_id)
											enemy_power = enemy_power + sim_offline_combat.calculate_squad_power(enemy_squad)
										end
										local attack_chance = (loner_power / enemy_power - 1) * 100
										if (loner_power) and (loner_power > enemy_power) and (attack_chance > math.random(1,100)) then
											all_targets[#all_targets+1] = other
										end
									end
								end
							end		
							
							if (#all_targets > 0) then
								local target = all_targets[math.random(#all_targets)]																	-- pick a random target from the list
								if enable_debug then
									printf("setting target of loners on base ".. smart:name() .. " to same-level resource: " ..target:name())
								end
								sim_squad_warfare.set_target(squad, target.id)
								target_set = true
							end
						else
							local level_info = warfare_levels.level_information[smart.level_id]
							
							for i,sm in pairs(level_info.smarts) do																							-- loop over all on-level smart terrains
								local other = sm and alife_object(sm)
							
								if not (other.owning_faction) then
									check_owner(other)
								end
								
								if (other.props and other.props.lair > 0 and other.props.base < 1 and other.props.resource < 1) and (other.owning_faction == "none") then				-- target pure lairs with no stalkers already present
									all_targets[#all_targets+1] = other
								end
							end		
							
							if (#all_targets > 0) then
								local target = all_targets[math.random(#all_targets)]
								if enable_debug then
									printf("setting target of loners on base ".. smart:name() .. " to same-level lair: " ..target:name())
								end
								sim_squad_warfare.set_target(squad, target.id)
								target_set = true
							end
						end
					end
					
					-- choosing to move off-level, or no empty resources found on-level. Go to a linked-level and find a resource
					if (target_set == false) then
						local linked = level_targets.level_links[smart.level_id]
						local keys = warfare.hash_table_to_array(linked)
						
						for k = 1,#keys do
							local chosen = keys[k].key
							local level_info = warfare_levels.level_information[chosen]
							
							for i,sm in pairs(level_info.smarts) do																				-- loop over all linked-level's smart terrains
								local other = sm and alife_object(sm)
							
								if not (other.owning_faction) then
									check_owner(other)
								end
								
								if (other.props and other.props.resource > 0) then																		-- only target resources
									if (other.owning_faction == "none") then																				-- prioritize empty resources
										priority_targets[#priority_targets+1] = other
									elseif (is_factions_enemies("stalker", other.owning_faction)) then
										local enemy_squads = SIMBOARD.smarts[other.id].squads
										local enemy_power = 0
										local loner_power = sim_offline_combat.calculate_squad_power(squad)
										for enemy_id,_ in pairs(enemy_squads) do
											local enemy_squad = enemy_id and alife_object(enemy_id)
											enemy_power = enemy_power + sim_offline_combat.calculate_squad_power(enemy_squad)
										end
										local attack_chance = (loner_power / enemy_power - 1) * 100
										if (loner_power) and (loner_power > enemy_power) and (attack_chance > math.random(1,100)) then
											all_targets[#all_targets+1] = other
										end
									elseif (other.props.base < 1) then																						-- if owned by neutral faction, only look at pure resources
										all_targets[#all_targets+1] = other
									end
								end
							end		
						end

						if (#priority_targets > 0) then
							local target = priority_targets[math.random(#priority_targets)]
							if enable_debug then
								printf("setting target of loners on base ".. smart:name() .. " to empty linked-level resource: " ..target:name())
							end
							sim_squad_warfare.set_target(squad, target.id)
							target_set = true
						elseif (#all_targets > 0) then
							local target = all_targets[math.random(#all_targets)]
							if enable_debug then
								printf("setting target of loners on base ".. smart:name() .. " to occupied linked-level resource: " ..target:name())
							end
							sim_squad_warfare.set_target(squad, target.id)
							target_set = true
						end
					end
				end
			
			-- updates squads at a pure resource or territory. Squads should select a new resource if daylight
			elseif (smart.props) and ((smart.props.resource > 0 and smart.props.base < 1) or (smart.props.territory > 0)) and (isDaylight or (math.random(100) <= night_chance)) then
				if (math.random(1, 10) < 7) then																									-- 70% chance of staying on-level
					local level_info = warfare_levels.level_information[smart.level_id]
					
					for i,sm in pairs(level_info.smarts) do
						local other = sm and alife_object(sm)
					
						if not (other.owning_faction) then
							check_owner(other)
						end
						
						if (other.props and other.props.resource > 0) then 
							if (other.owning_faction == "none") then
								all_targets[#all_targets+1] = other
							elseif (is_factions_enemies("stalker", other.owning_faction)) then
								local enemy_squads = SIMBOARD.smarts[other.id].squads
								local enemy_power = 0
								local loner_power = sim_offline_combat.calculate_squad_power(squad)
								for enemy_id,_ in pairs(enemy_squads) do
									local enemy_squad = enemy_id and alife_object(enemy_id)
									enemy_power = enemy_power + sim_offline_combat.calculate_squad_power(enemy_squad)
								end
								local attack_chance = (loner_power / enemy_power - 1) * 100
								if (loner_power) and (loner_power > enemy_power) and (attack_chance > math.random(1,100)) then
									all_targets[#all_targets+1] = other
								end
							end
						end
					end		
	
					if (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of loners on resource ".. smart:name() .. " to same-level resource: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end
				
				if (target_set == false) then																										-- choosing to move off-level, or no empty resources found on-level. Go to a linked-level and find a resource, occupied or not
					local linked = level_targets.level_links[smart.level_id]
					local keys = warfare.hash_table_to_array(linked)
					
					for k = 1,#keys do
						local chosen = keys[k].key
						local level_info = warfare_levels.level_information[chosen]
					
						for i,sm in pairs(level_info.smarts) do
							local other = sm and alife_object(sm)
						
							if not (other.owning_faction) then
								check_owner(other)
							end
							
							if (other.props and other.props.resource > 0) then
								if (other.owning_faction == "none") then
									priority_targets[#priority_targets+1] = other
								elseif (is_factions_enemies("stalker", other.owning_faction)) then
									local enemy_squads = SIMBOARD.smarts[other.id].squads
									local enemy_power = 0
									local loner_power = sim_offline_combat.calculate_squad_power(squad)
									for enemy_id,_ in pairs(enemy_squads) do
										local enemy_squad = enemy_id and alife_object(enemy_id)
										enemy_power = enemy_power + sim_offline_combat.calculate_squad_power(enemy_squad)
									end
									local attack_chance = (loner_power / enemy_power - 1) * 100
									if (loner_power) and (loner_power > enemy_power) and (attack_chance > math.random(1,100)) then
										all_targets[#all_targets+1] = other
									end
								elseif (other.props.base < 1) then
									all_targets[#all_targets+1] = other
								end
							end
						end
					end
	
					if (#priority_targets > 0) then
						local target = priority_targets[math.random(#priority_targets)]
						if enable_debug then
							printf("setting target of loners on resource ".. smart:name() .. " to empty linked-level resource: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					elseif (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of loners on resource ".. smart:name() .. " to occupied linked-level resource: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end

			-- updates squads at a pure lair. Squads should select a new lair on the same level if daylight, or select a base if getting late.
			elseif (smart.props and smart.props.lair > 0 and smart.props.base < 1 and smart.props.resource < 1) and (isDaylight or (math.random(100) <= night_chance)) then
				local level_info = warfare_levels.level_information[smart.level_id]
				
				for i,sm in pairs(level_info.smarts) do
					local other = sm and alife_object(sm)
				
					if not (other.owning_faction) then
						check_owner(other)
					end
					
					if (other.props and other.props.lair > 0 and other.props.base < 1 and other.props.resource < 1) and (other.owning_faction == "none") then					-- only target pure lairs with no stalkers already present
						all_targets[#all_targets+1] = other
					end
				end		
	
				if (#all_targets > 0) then
					local target = all_targets[math.random(#all_targets)]
					if enable_debug then
						printf("setting target of loners on lair ".. smart:name() .. " to same-level lair: " ..target:name())
					end
					sim_squad_warfare.set_target(squad, target.id)
					target_set = true
				end
			end
			
			local all_targets = {}				-- reset for below
			local priority_targets = {}			-- reset for below
			
			if (smart.props and smart.props.base < 1) and (isSunset or isNight) and (target_set == false) then										-- send loners back to base, unless they're assigned for night activity
				if (math.random(1,10) < 8) then																										-- 80% chance to first stay on level if possible
					local level_info = warfare_levels.level_information[smart.level_id]
					for i,sm in pairs(level_info.smarts) do
						local other = sm and alife_object(sm)
					
						if not (other.owning_faction) then
							check_owner(other)
						end
						
						if (other.props and other.props.base > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then				-- only target bases that are empty or with non-hostile forces present
							if (other.owning_faction ~= "none") then
								local num_squads = squad_count(other, other.owning_faction)
								if (other.owning_faction == faction) and (num_squads < other.max_population) then																	-- prioritize loner-owned bases
									priority_targets[#priority_targets+1] = other
								elseif (num_squads < other.max_population) then
									all_targets[#all_targets+1] = other
								end
							else
								all_targets[#all_targets+1] = other
							end
						end
					end		
		
					if (#priority_targets > 0) then
						local target = priority_targets[math.random(#priority_targets)]
						if enable_debug then
							printf("setting target of loners on ".. smart:name() .. " to same-level loner base: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					elseif (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of loners on ".. smart:name() .. " to same-level " .. target.owning_faction .. " base: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end
				
				-- only hostile bases found on-level, or choosing to move levels. Go to a linked-level and find a base
				if (target_set == false) then
					local linked = level_targets.level_links[smart.level_id]
					local keys = warfare.hash_table_to_array(linked)
					
					for k = 1,#keys do
						local chosen = keys[k].key
						local level_info = warfare_levels.level_information[chosen]

						for i,sm in pairs(level_info.smarts) do
							local other = sm and alife_object(sm)
						
							if not (other.owning_faction) then
								check_owner(other)
							end
							
							if (other.props and other.props.base > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then			-- only target bases that are empty or with non-hostile forces present
								if (other.owning_faction ~= "none") then
									local num_squads = squad_count(other, other.owning_faction)
									if (other.owning_faction == faction) and (num_squads < other.max_population) then																-- prioritize loner-owned bases
										priority_targets[#priority_targets+1] = other
									elseif (num_squads < other.max_population) then
										all_targets[#all_targets+1] = other
									end
								else
									all_targets[#all_targets+1] = other
								end
							end
						end
					end

					if (#priority_targets > 0) then
						local target = priority_targets[math.random(#priority_targets)]
						if enable_debug then
							printf("setting target of loners on ".. smart:name() .. " to linked-level loner base: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					elseif (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of loners on ".. smart:name() .. " to linked-level " .. target.owning_faction .. " base: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end
				
				-- couldn't find non-hostile/non-full base on linked levels - pick a territory on-level, occupied or not
				if (target_set == false) then
					local level_info = warfare_levels.level_information[smart.level_id]
					for i,sm in pairs(level_info.smarts) do
						local other = sm and alife_object(sm)
					
						if not (other.owning_faction) then
							check_owner(other)
						end
						
						if (other.props and other.props.territory > 0) then
							all_targets[#all_targets+1] = other
						end
					end
	
					if (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of loners on ".. smart:name() .. " to same-level territory: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end
			end
		end
	end
end


-- Code to handle ecologist behavior, including targeting of locations, travel to and from those points, etc.
function process_ecolog(smart)

	if not (ecolog_timer[smart.id]) then
		ecolog_timer[smart.id] = game.get_game_time()
		ecolog_next_update[smart.id] = math.random(60, 180)				-- time in in-game minutes
		return
	end

	if (game.get_game_time():diffSec(ecolog_timer[smart.id]) >= ecolog_next_update[smart.id]*60) and not currently_surge then
		ecolog_timer[smart.id] = game.get_game_time()
		ecolog_next_update[smart.id] = math.random(60, 180)
	else
		return
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads							-- get info of all squads at location

	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		local faction = squad:get_squad_community()							-- get faction of squads
		
		if (faction == "ecolog") and squad_is_commandable(squad, true) and (squad.current_action == 1) then								-- only operate on ecologists, exclude unique npcs
			local night_chance = warfare_options.options.factions[faction].night_activity_chance
			local isNight = (level.get_time_hours() < 6 or level.get_time_hours() > 20)
			local isDaylight = (level.get_time_hours() > 5 and level.get_time_hours() < 16)
			local isSunset = (level.get_time_hours() > 17 and level.get_time_hours() < 21)
			
			local target_set = false
			local all_targets = {}
	
			if (smart.props and smart.props.base > 0) and (isDaylight) and (math.random(1,10) < 9) then												-- updates squads at a base. Squads are assigned to resource locations during daylight hours. 10% chance that they're lazy bums and sit at base until the next update
				if ((smart.owning_faction ~= "ecolog") or (smart.owning_faction == "ecolog" and squad_count(smart, "ecolog") > 1)) then				-- Ecologist-owned bases keep their last squad to retain control
					if (math.random(1, 10) < 5) then																									-- 50% chance of staying on-level
						local level_info = warfare_levels.level_information[smart.level_id]
						
						for i,sm in pairs(level_info.smarts) do
							local other = sm and alife_object(sm)
							
							if not (other.owning_faction) then
								check_owner(other)
							end
							
							if (other.props and other.props.resource > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then		-- target empty resources or resources with non-hostile stalkers
								all_targets[#all_targets+1] = other
							end
						end		
						
						if (#all_targets > 0) then
							local target = all_targets[math.random(#all_targets)]
							if enable_debug then
								printf("setting target of ecologists at base ".. smart:name() .. " to same-level resource: " ..target:name())
							end
							sim_squad_warfare.set_target(squad, target.id)
							target_set = true
						end
					
					end
					
					if (target_set == false) then																										-- choosing to move off-level. Go to a linked-level and find a resource
						local linked = level_targets.level_links[smart.level_id]
						local keys = warfare.hash_table_to_array(linked)
						local chosen = keys[math.random(#keys)].key
						local level_info = warfare_levels.level_information[chosen]
						
						for i,sm in pairs(level_info.smarts) do
							local other = sm and alife_object(sm)
							
							if not (other.owning_faction) then
								check_owner(other)
							end
							
							if (other.props and other.props.resource > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then
								all_targets[#all_targets+1] = other
							end
						end		
						
						if (#all_targets > 0) then
							local target = all_targets[math.random(#all_targets)]
							if enable_debug then
								printf("setting target of ecologists at base ".. smart:name() .. " to linked-level resource: " ..target:name())
							end
							sim_squad_warfare.set_target(squad, target.id)
							target_set = true
						end
					end
				end
		
			elseif (smart.props) and ((smart.props.resource > 0 and smart.props.base < 1) or (smart.props.territory > 0)) and (isDaylight or (math.random(100) <= night_chance)) then 					-- updates squads at a pure resource or territory. Squads should select a new resource if daylight
				if (math.random(1, 10) < 5) then																									-- 50% chance of staying on-level
					local level_info = warfare_levels.level_information[smart.level_id]
					
					for i,sm in pairs(level_info.smarts) do
						local other = sm and alife_object(sm)
						
						if not (other.owning_faction) then
							check_owner(other)
						end
						
						if (other.props and other.props.resource > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then
							all_targets[#all_targets+1] = other
						end
					end		
	
					if (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of ecologists on resource ".. smart:name() .. " to same-level resource: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end
				
				if (target_set == false) then																										-- choosing to move off-level. Go to a linked-level and find a resource
					local linked = level_targets.level_links[smart.level_id]
					local keys = warfare.hash_table_to_array(linked)
					local chosen = keys[math.random(#keys)].key
					local level_info = warfare_levels.level_information[chosen]
					
					for i,sm in pairs(level_info.smarts) do
						local other = sm and alife_object(sm)
						
						if not (other.owning_faction) then
							check_owner(other)
						end
						
						if (other.props and other.props.resource > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then		-- target empty resources or resources with non-hostile stalkers
							all_targets[#all_targets+1] = other
						end
					end		
	
					if (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of ecologists on resource ".. smart:name() .. " to linked-level resource: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end
			end
			
			local priority_targets = {}
			local backup_targets_on = {}
			local backup_targets_off = {}
			
			if (smart.props and smart.props.base < 1) and (isSunset or isNight) and (target_set == false) then										-- send ecologists back to base, unless they're assigned for night activity
				local level_info = warfare_levels.level_information[smart.level_id]																	-- first check current level for bases, then linked levels.
				for i,sm in pairs(level_info.smarts) do																								-- only ecologist bases will be priority bases, others will be chosen randomly
					local other = sm and alife_object(sm)
				
					if not (other.owning_faction) then
						check_owner(other)
					end
					
					if (other.props and other.props.base > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then				-- only target bases that are empty or with non-hostile forces present
						if (other.owning_faction ~= "none") then
							local num_squads = squad_count(other, other.owning_faction)
							if (other.owning_faction == faction) and (num_squads < other.max_population) then																-- prioritize on-level ecologist bases first
								priority_targets[#priority_targets+1] = other
							elseif (num_squads < other.max_population) then
								backup_targets_on[#backup_targets_on+1] = other																							-- corresponds to all qualified on-level bases
							end
						else
							backup_targets_on[#backup_targets_on+1] = other
						end
					end
				end		

				if not (#priority_targets > 0) then																									-- only look at linked levels if there isn't an ecologist base on current level
					local linked = level_targets.level_links[smart.level_id]
					local keys = warfare.hash_table_to_array(linked)	
					
					for k = 1,#keys do																													-- look at all linked levels
						local chosen = keys[k].key
						local level_info = warfare_levels.level_information[chosen]
					
						for i,sm in pairs(level_info.smarts) do
							local other = sm and alife_object(sm)
						
							if not (other.owning_faction) then
								check_owner(other)
							end
							
							if (other.props and other.props.base > 0) and (other.owning_faction == "none" or not is_factions_enemies(faction, other.owning_faction)) then			-- only target bases that are empty or with non-hostile forces present
								if (other.owning_faction ~= "none") then
									local num_squads = squad_count(other, other.owning_faction)
									if (other.owning_faction == faction) and (num_squads < other.max_population) then																-- prioritize any linked ecologist-owned bases
										priority_targets[#priority_targets+1] = other
									elseif (num_squads < other.max_population) then
										backup_targets_off[#backup_targets_off+1] = other																				-- more backup bases in case all on-level bases are hostile
									end
								else
									backup_targets_off[#backup_targets_off+1] = other
								end
							end
						end
					end
				end

				if (#priority_targets > 0) then																						-- first priority for ecologist bases
					local target = priority_targets[math.random(#priority_targets)]
					if enable_debug then
						printf("setting target of ecologists on ".. smart:name() .. " to ecologist base: " ..target:name())
					end
					sim_squad_warfare.set_target(squad, target.id)
					target_set = true
				elseif (#backup_targets_on > 0) then																					-- otherwise try on-level neutral/empty bases
					local target = backup_targets_on[math.random(#backup_targets_on)]
					if enable_debug then
						printf("setting target of ecologists on ".. smart:name() .. " to same-level " .. target.owning_faction .. " base: " ..target:name())
					end
					sim_squad_warfare.set_target(squad, target.id)
					target_set = true
				elseif (#backup_targets_off > 0) then																				-- if no available on-level bases, pick a linked-level neutral/empty base
					local target = backup_targets_off[math.random(#backup_targets_off)]
					if enable_debug then
						printf("setting target of ecologists on ".. smart:name() .. " to linked-level " .. target.owning_faction .. " base: " ..target:name())
					end
					sim_squad_warfare.set_target(squad, target.id)
					target_set = true
				end
				
				if (target_set == false) then																	-- couldn't find non-hostile/non-full base on linked levels - pick a territory on-level, occupied or not
					local level_info = warfare_levels.level_information[smart.level_id]							-- this is only for contingency, and realistically should never happen
					for i,sm in pairs(level_info.smarts) do
						local other = sm and alife_object(sm)
					
						if not (other.owning_faction) then
							check_owner(other)
						end
						
						if (other.props and other.props.territory > 0) then
							all_targets[#all_targets+1] = other
						end
					end
	
					if (#all_targets > 0) then
						local target = all_targets[math.random(#all_targets)]
						if enable_debug then
							printf("setting target of ecologists on ".. smart:name() .. " to same-level territory: " ..target:name())
						end
						sim_squad_warfare.set_target(squad, target.id)
						target_set = true
					end
				end
			end
		end
	end
end



function spawn_mutants(smart)
	if (smart.props.base > 0) or (smart.props.resource > 0) or (smart.props.territory > 0) or (smart.props.lair < 1) then
		--printf("Cannot spawn mutants at base/resource/territory location: " .. smart:name())
		return
	elseif not (spawn_mutant_timers[smart.id]) then
		local min_respawn = warfare_options.options.monster_min_faction_respawn
		local max_respawn = warfare_options.options.monster_max_faction_respawn
		spawn_mutant_next_update[smart.id] = math.random(min_respawn, max_respawn)
		spawn_mutant_timers[smart.id] = game.get_game_time()			-- these timers and the update timers now get saved, and don't reset upon game load!
		return
	elseif (game.get_game_time():diffSec(spawn_mutant_timers[smart.id]) > (spawn_mutant_next_update[smart.id]*60)) then
		--printf("time to spawn mutants on location: " .. smart:name())
		local min_respawn = warfare_options.options.monster_min_faction_respawn
		local max_respawn = warfare_options.options.monster_max_faction_respawn
		spawn_mutant_next_update[smart.id] = math.random(min_respawn, max_respawn)
		spawn_mutant_timers[smart.id] = game.get_game_time()
	else
		--printf("not ready to spawn mutants at " .. smart:name() .. " more time needed: " .. game.get_game_time():diffSec(spawn_mutant_timers[smart.id]) .. " out of " .. (spawn_mutant_next_update[smart.id]*60))
		return
	end
	
	printd(0, smart:name())
	
	if (smart.is_on_actor_level and smart.dist_to_actor ~= nil) then 
		if (smart.dist_to_actor < smart.respawn_radius) then
			printd(1, smart:name())
			return
		end
	end

	local current_level = smart.level_id
	local max_active = round_idp(math.min(warfare_options.options.monster_max_squads_per_level, monster_level_capacity[current_level] * ui_options.get("alife/general/alife_mutant_pop")))		-- max allowable squads is min of user setting or level-specific capacity
	local rare_chance = warfare_options.options.monster_rare_chance_south

	if (current_level > 12) and (current_level < 32) then									-- levels 13 - 31 include all levels north of military warehouses/dead city/trucks cemetery. Also includes all labs. See level_targets.script for more info
		if ((current_level > 19) and (current_level < 27)) or (current_level == 29) or (current_level == 31) then								-- labs will spawn scary mutants
			max_active = round_idp(math.min(max_active, warfare_options.options.monster_max_squads_per_level_lab))			-- max monster squads in labs is min of level-allowed max and user setting
			rare_chance = warfare_options.options.monster_rare_chance_lab
		else
			rare_chance = warfare_options.options.monster_rare_chance_north
		end
	end
	
	local mutants_on_level = sim_offline_combat.get_num_squads_on_level(smart.level_id, "monster")
	
	if (mutants_on_level < max_active) then
		-- see if any existing mutants are on the smart
		local spawned = false
		local squads = SIMBOARD.smarts[smart.id].squads
		for sid,_ in pairs(squads) do
			local squad = sid and alife_object(sid)
			if squad then
				local faction = squad:get_squad_community()
				if (faction == "monster") and (not warfare.ignore[squad:section_name()]) and (not sim_offline_combat.stationary_squads[squad:section_name()]) and (squad.current_action == 1) then
					-- get squad section name
					local section = squad:section_name()
					local new_squad = utils_obj.create_squad(section, smart:name())	-- create identical section
					sim_squad_warfare.set_target(squad, smart.id)
					spawned = true
					if enable_debug then
						printf("spawning %s on terrain %s which already had %s.", section, smart:name(), section)
					end
					break
				end
			end
		end
		
		if not spawned then
			local section = faction_expansions.get_spawn_section("monster", rare_chance)
			local squad = utils_obj.create_squad(section, smart:name())
			sim_squad_warfare.set_target(squad, smart.id)
			if enable_debug then
				printf("spawning %s on empty terrain %s. There are now %s / %s mutant squads on that level", section, smart:name(), (mutants_on_level+1), max_active)
			end
		end
	end
	
	printd(2, smart:name())
end

-- Will be used for handling mutant behavior, choosing new targets etc.
function process_mutants(smart)
	if not (process_mutant_timers[smart.id]) or (game.get_game_time():diffSec(process_mutant_timers[smart.id]) >= (process_mutant_next_update[smart.id]*60)) then
		process_mutant_timers[smart.id] = game.get_game_time()
		local min_respawn = warfare_options.options.monster_min_faction_respawn
		local max_respawn = warfare_options.options.monster_max_faction_respawn
		process_mutant_next_update[smart.id] = math.random(min_respawn, max_respawn)
	else
		--printf("not ready to change mutant target at " .. smart:name() .. " more time needed: " .. game.get_game_time():diffSec(process_mutant_timers[smart.id]) .. " out of " .. (process_mutant_next_update[smart.id]*60))
		return
	end
	
	printd(0, smart:name())
		
	local squads = SIMBOARD.smarts[smart.id].squads
	
	-- count squads on smart
	local mutant_squad_count = 0
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		if squad then
			local faction = squad:get_squad_community()
			if (faction == "monster") and (not warfare.ignore[squad:section_name()]) and (not sim_offline_combat.stationary_squads[squad:section_name()]) then
				if (squad.current_action == 1) then			-- mutant squad is idle
					if not (squad.wait_time) then
						squad.wait_time = math.random(10, 60)			-- make them wait for some number of in-game minutes
					end
				end	
				mutant_squad_count = mutant_squad_count + 1
			end
		end
	end
			
	-- potentially send mutant to a new smart terrain
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		if squad then
			local faction = squad:get_squad_community()
			if (faction == "monster") and (not warfare.ignore[squad:section_name()]) and (not sim_offline_combat.stationary_squads[squad:section_name()]) then			
				if (squad.arrive_time and squad.wait_time) then		
					-- force a mutant squad to move off if they exceed the terrain capacity
					if (game.get_game_time():diffSec(squad.arrive_time) >= squad.wait_time*60) or (mutant_squad_count > smart.max_population) then
						local max_active = warfare_options.options.monster_max_squads_per_level		
						
						local targets = {}
						
						-- Just for now, 1 in 20 chance of moving off level.
						-- TODO: Make this an option that can be tweaked
						if (math.random(1, 20) > 19) then		
							local current_level = smart.level_id
							if not ( ((current_level > 19) and (current_level < 27)) or (current_level == 29) or (current_level == 31) ) then	-- forbid mutants inside labs from changing levels
								local linked = level_targets.level_links[smart.level_id]
								local keys = warfare.hash_table_to_array(linked)
								local chosen = keys[math.random(#keys)].key
								local level_info = warfare_levels.level_information[chosen]
								local mutants_on_level = sim_offline_combat.get_num_squads_on_level(chosen, "monster")	
									
								if (mutants_on_level < max_active) then
									for i,sm in pairs(level_info.smarts) do
										local other = sm and alife_object(sm)
									
										if not (other.owning_faction) then
											check_owner(other)
										end
										
										if (other.owning_faction == "none") or ((other.owning_faction ~= "none") and (math.random(1, 20) > 19)) then					-- 1 in 20 chance of attacking a STALKER-occupied location
											if not (warfare_options.options.prevent_mainbase_attacks and main_bases[other:name()]) then
												targets[#targets+1] = other																									-- add possible locations to list of targets
											end
										end
									end
			
									if (#targets > 0) then
										local target = targets[math.random(#targets)]
										local num_targeting = squad_count_targeting(target, "monster")
										if enable_debug then
											printf("setting target of mutants on ".. smart:name() .. " to linked-level target: " ..target:name())
										end
										sim_squad_warfare.set_target(squad, target.id)
									end
								end
							end
						else		
							local level_info = warfare_levels.level_information[smart.level_id]
							local mutants_on_level = sim_offline_combat.get_num_squads_on_level(smart.level_id, "monster")
							
							for i,sm in pairs(level_info.smarts) do
								local other = sm and alife_object(sm)
								
								if not (other.owning_faction) then
									check_owner(other)
								end
									
								if (other.owning_faction == "none") or ((other.owning_faction ~= "none") and (math.random(1, 20) > 19)) then					-- 1 in 20 chance of attacking a STALKER-occupied location
									if not (warfare_options.options.prevent_mainbase_attacks and main_bases[other:name()]) then
										targets[#targets+1] = other																									-- add possible locations to list of targets
									end
								end
							end
	
							if (#targets > 0) then
								local target = targets[math.random(#targets)]
								local num_targeting = squad_count_targeting(target, "monster")
								if enable_debug then
									printf("setting target of mutants on ".. smart:name() .. " to same-level target: " ..target:name())
								end
								sim_squad_warfare.set_target(squad, target.id)
							end
						end
					end
				end
			end
		end
	end
	
	printd(1, smart:name())
end

function get_faction_power(smart, faction)
	local squads = SIMBOARD.smarts[smart.id].squads
	local power = 0
	
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)

		if (squad) then
			if (squad.current_action == 1 and squad.registered_with_warfare) then
				if (squad:get_squad_community() == faction) then
					power = power + sim_offline_combat.calculate_squad_power(squad)	
				end
			end
		end
	end
	
	return power
end

-- displays warfare's icon for the smart terrain
-- controls smart terrain icons only, not squad dots
--function smart_terrain.se_smart_terrain.show(self)
--function update_icon_smart_terrain(smart)
function smart_terrain.se_smart_terrain:show()
	if DEV_DEBUG and (dbg_hud) then
		if (level.map_has_object_spot(self.id,"alife_presentation_smart_default_neutral") == 0) then
			level.map_add_object_spot(self.id, "alife_presentation_smart_default_neutral", self:get_smart_props())
		else
			level.map_change_spot_hint(self.id, "alife_presentation_smart_default_neutral", self:get_smart_props())
		end
	else
		if (level.map_has_object_spot(self.id,"alife_presentation_smart_default_neutral") ~= 0) then 
			level.map_remove_object_spot(self.id, "alife_presentation_smart_default_neutral")
		end
	end

    printd(0, self:name())
	
	local c = 0	
	
	local faction = self.owning_faction or "none"
	local actor_faction = faction == warfare.actor_faction		-- is 'true' when the smart belongs to the player's faction
	
	local friends = is_factions_friends(warfare.actor_faction, faction)
	local enemies = is_factions_enemies(warfare.actor_faction, faction)

	local actor_level

	if IsWarfare() then
		-- fog of war
		if (warfare_options.options.fog_of_war) then
			local lvl = game_graph():vertex(self.m_game_vertex_id):level_id()
			local visible = false
	
			if (sim_offline_combat.squads_by_level[lvl] ~= nil) then			
				local fog_of_war_distance = warfare_options.options.fog_of_war_distance
				fog_of_war_distance = tonumber(fog_of_war_distance)
				-- check smart distance to active squads on level
				if (self.is_on_actor_level) then
					local dist = warfare.distance_to_xz_sqr(self.position, alife():actor().position)
	
					if (dist < fog_of_war_distance*fog_of_war_distance) then
						visible = true
					end
				end
				
				-- determine visibility granted by allied squads
				if not (visible) then
					for squadID,_ in pairs(sim_offline_combat.squads_by_level[lvl]) do
						local squad = squadID and alife_object(squadID)
	
						if (squad and squad:clsid() == clsid.online_offline_group_s) then
							-- actor can always see anything within the fog of war distance of their faction and any allied factions
							-- loners cannot see other loner bases outside of fog of war
							if ( (squad:get_squad_community() == warfare.actor_faction and (warfare.actor_faction ~= "stalker" or not warfare_options.options.loner_fog)) or is_factions_friends(squad:get_squad_community(), warfare.actor_faction) ) then
								if (warfare.distance_to_xz_sqr(squad.position, self.position) < fog_of_war_distance*fog_of_war_distance) then
									visible = true
									break
								end
							end
						end
					end
				end
				
				if not (self.target_spots) then
					self.target_spots = {}	-- initialize red target spots
				end

				if not (self.target_smarts) then
					self.target_smarts = {}	-- initialize
				end
				
				for t,spot in pairs(self.target_spots) do
					local other = alife_object(t)
					
					if (other) then
						-- clear target spots from points owned by neutrals
						if (other.owning_faction == warfare.actor_faction or (other.owning_faction ~= "none" and not is_factions_enemies(other.owning_faction, warfare.actor_faction))) then
							level.map_remove_object_spot(t, pda_icons[spot])
							self.target_spots[t] = nil
							other.actor_target = nil
						else
							level.map_change_spot_hint(t, pda_icons[spot], get_target_info(other))
						end
					end
				end
				
				-- smart belongs to player's faction
				if (actor_faction) then
					for t,_ in pairs(self.target_smarts) do
						if not (self.target_spots[t]) then				
							local other = alife_object(t)
							
							if (other) then						
								if ((not other.actor_target) and other.owning_faction ~= warfare.actor_faction and (other.owning_faction == "none" or is_factions_enemies(other.owning_faction, warfare.actor_faction))) then				
									other.actor_target = true
									
									other:hide()
									
									level.map_add_object_spot(t, "circle_target", get_target_info(other))		-- add red target spots to map
									self.target_spots[t] = "target"
								end						
							end
						end
					end
				end

				-- actor can always see members of their own faction no matter the distance, as well as allied factions
				if ( (faction == warfare.actor_faction and (warfare.actor_faction ~= "stalker" or not warfare_options.options.loner_fog)) or is_factions_friends(faction, warfare.actor_faction) ) then
					visible = true
				end
	
				-- 'hide underground smarts' option
				if (warfare_names.point_names_hide[self:name()] and warfare_options.options.hide_undegraund_smarts) then
					visible = false
				end

				if (self.actor_target) then
					visible = false
				end
	
				-- hide empty useless smarts within visible range
				if (warfare_options.options.hide_lair_smarts) and (faction == "none") and (self.props.base + self.props.resource + self.props.territory < 1) then
					visible = false
				end
	
				--[[
				-- if 'hide_smarts' is used, also hide all empty smart spots within visible range
				if (warfare_options.options.hide_smarts or hide_smarts) and (faction == "none") then
					visible = false
				end
				--]]
	
				if (visible) then
					local info = nil
					
					-- determine info to show on visible smarts
					if (faction == warfare.actor_faction or is_factions_friends(faction, warfare.actor_faction)) then
						info = get_warfare_info(self)
					elseif (is_factions_enemies(warfare.actor_faction, faction)) then
						info = get_target_info(self, true)					
					else
						info = get_neutral_info(self)
					end

					-- if spot already exists, remove it and re-add it to update
					if (self.warfare_spot) then
						if (self.warfare_spot ~= faction) then			-- smart owner doesn't match icon of the owner
							level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
							level.map_add_object_spot(self.id, pda_icons[faction], info)		-- update smart icon
							self.warfare_spot = faction
						else
							level.map_change_spot_hint(self.id, pda_icons[faction], info)
						end
					else
						level.map_add_object_spot(self.id, pda_icons[faction], info)		-- if no spot already, add it
						self.warfare_spot = faction
					end
					
				else
				-- not visible based on actor and friendly squad view distances
					if (not self.actor_target) then
						local info = get_unknown_info(self)

						-- map spot already exists: hide it or replace it depending on options
						if (self.warfare_spot) then
							-- if hiding all nonvisible smarts, remove spots
							if (warfare_options.options.hide_smarts or hide_smarts) then
								level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
								self.warfare_spot = nil
							-- if hiding only lair smarts, remove spots from lairs but make 'unknown' spots on valuable nonvisible terrains
							elseif (warfare_options.options.hide_lair_smarts) and (self.props.base + self.props.resource + self.props.territory < 1) then
								level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
								self.warfare_spot = nil
							-- neither option is being used
							else
								if (self.warfare_spot ~= "none") then
									level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
									level.map_add_object_spot(self.id, pda_icons["none"], info)
									self.warfare_spot = "none"
								else
									level.map_change_spot_hint(self.id, pda_icons["none"], info)
								end
							end
							
						-- map spot doesn't exist: create it or do nothing depending on options
						else
							-- don't do anything if hiding nonvisible smarts
							if not (warfare_options.options.hide_smarts or hide_smarts) then
								-- hiding lair terrains
								if (warfare_options.options.hide_lair_smarts) then
									-- smart is a valuable nonvisible terrain: add 'unknown' spot
									if (self.props.base + self.props.resource + self.props.territory > 0) then
										level.map_add_object_spot(self.id, pda_icons["none"], info)
										self.warfare_spot = "none"
									end
								-- not using either option, so need to add 'unknown' spots to all smarts
								else
									level.map_add_object_spot(self.id, pda_icons["none"], info)
									self.warfare_spot = "none"
								end
							end
						end
					end
					
					local name_self = self:name()
					local rus_name = warfare_names.point_names_hide[name_self] and (game.translate_string("st_" .. name_self .. "_name")) or name_self
					if (rus_name ~= name_self and warfare_options.options.hide_undegraund_smarts) then
						if (self.warfare_spot) then
							if (self.warfare_spot==faction) then
								level.map_remove_object_spot(self.id, pda_icons[faction])
							else
								level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
							end
							self.warfare_spot = nil
						end
					end
				end
			end
		
		-- not fog of war
		else
			if not (self.target_spots) then
				self.target_spots = {}
			end

			-- handle removal of red target spots
			for t,spot in pairs(self.target_spots) do
				local other = alife_object(t)
				
				if (other) then
					if (other.owning_faction == warfare.actor_faction or not (other.owning_faction == "none" or is_factions_enemies(other.owning_faction, warfare.actor_faction))) then
						level.map_remove_object_spot(t, pda_icons[spot])
						self.target_spots[t] = nil
						other.actor_target = nil
					else
						level.map_change_spot_hint(t, pda_icons[spot], get_warfare_info(other))
					end
				end
			end	
			
			-- handle addition of red target spots
			if (actor_faction and self.target_smarts) then
				for t,_ in pairs(self.target_smarts) do
					if not (self.target_spots[t]) then				
						local other = alife_object(t)
						
						if (other) then						
							if ((not other.actor_target) and other.owning_faction ~= warfare.actor_faction and (other.owning_faction == "none" or is_factions_enemies(other.owning_faction, warfare.actor_faction))) then				
								other.actor_target = true
								
								other:hide()
								
								level.map_add_object_spot(t, "circle_target", get_target_info(other))
								self.target_spots[t] = "target"
							end						
						end
					end
				end
			end
			
			if not (self.actor_target) then					
				local info = nil

				-- update info for each spot
				if (faction == warfare.actor_faction or is_factions_friends(faction, warfare.actor_faction)) then
					info = get_warfare_info(self)
				elseif (is_factions_enemies(warfare.actor_faction, faction)) then
					info = get_target_info(self)					
				else
					info = get_neutral_info(self)
				end

				-- map spot already exists: hide it or replace it depending on options
				if (self.warfare_spot) then
					-- if hiding all nonvisible smarts, remove spots
					if (warfare_options.options.hide_smarts or hide_smarts) then
						level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
						self.warfare_spot = nil
					-- if hiding only lair smarts, remove spots from unoccupied (no stalker) lairs
					elseif (warfare_options.options.hide_lair_smarts) and (self.props.base + self.props.resource + self.props.territory < 1) and (faction == "none") then
						level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
						self.warfare_spot = nil
					-- neither option is being used
					else
						-- update icon with correct visual and info
						if (self.warfare_spot ~= faction) then
							level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
							level.map_add_object_spot(self.id, pda_icons[faction], info)
							self.warfare_spot = faction
						else
							level.map_change_spot_hint(self.id, pda_icons[faction], info)
						end
					end
				
				-- map spot doesn't exist: create it or do nothing depending on options
				else
					-- don't do anything if hiding nonvisible smarts
					if not (warfare_options.options.hide_smarts or hide_smarts) then
						-- hiding lair terrains
						if (warfare_options.options.hide_lair_smarts) then
							-- smart is a valuable nonvisible but occupied terrain: add faction spot
							if (self.props.base + self.props.resource + self.props.territory > 0) or (faction ~= "none") then
								level.map_add_object_spot(self.id, pda_icons[faction], info)
								self.warfare_spot = faction
							end
						-- not using either option, so need to add faction spots to all smarts
						else
							level.map_add_object_spot(self.id, pda_icons[faction], info)
							self.warfare_spot = faction
						end
					end
				end
			end
			
	-------------------av661194
			local name_self = self:name()
			local rus_name = warfare_names.point_names_hide[name_self] and (game.translate_string("st_" .. name_self .. "_name")) or name_self
			if (rus_name ~= name_self and warfare_options.options.hide_undegraund_smarts) then
				if (self.warfare_spot) then
					if (self.warfare_spot==faction) then
						level.map_remove_object_spot(self.id, pda_icons[faction])
					else
						level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])
					end
					self.warfare_spot = nil
				end
			end
	--------------------av661194
		end
	end
	
    printd(1, self:name())
end

function smart_terrain.se_smart_terrain:hide()
	
    printd(0, self:name())
	
	if (self.warfare_spot) then
		level.map_remove_object_spot(self.id, pda_icons[self.warfare_spot])		
		self.warfare_spot = nil
	end
	
	if (self.target_spots) then
		for t,spot in pairs(self.target_spots) do
			local other = alife_object(t)
			
			if (other) then
				level.map_remove_object_spot(t, pda_icons[spot])
				self.target_spots[t] = nil
				other.actor_target = nil
				other:show()
			end
		end	
	end
	
    printd(1, self:name())	
end

function get_unknown_info(smart)
    printd(0, smart:name())
	
    local owning_faction = warfare_names.faction_names[smart.owning_faction]
	local warfareName = translate_smart_name(smart:name())	or smart:name()
	local props = clr_o .. warfareName .. " \\n"
	props = props .. clr_o .. "................................\\n "	.. clr_gr

	if (smart.props) then
		if (smart.props.base > 0) then
			props = props .. " \\n" .. str_wrfr[2] .. " \\n"
		end
		
		if (smart.props.resource > 0) then
			props = props .. " \\n" .. str_wrfr[3] .. " \\n"
		end

		if (smart.props.territory > 0) then
			props = props .. " \\n" .. str_wrfr[4] .. " \\n"
		end
	end
	
    printd(1, smart:name())
	return props
end

function get_neutral_info(smart)
    printd(0, smart:name())
	
    local owning_faction = warfare_names.faction_names[smart.owning_faction]
	local warfareName = translate_smart_name(smart:name())	or smart:name()
	local props = clr_o .. warfareName .. " \\n"
	props = props .. clr_o .. "................................ \\n".. clr_gr

	if (smart.owning_faction) then
		props = props .. " \\n" .. clr_gr .. str_wrfr[6] .. ": " .. clr_w .. game.translate_string(smart.owning_faction) .. "\\n"
	end

	if (smart.props) then
		if (smart.props.base > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[2] .. " \\n"
		end
		
		if (smart.props.resource > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[3] .. " \\n"
		end

		if (smart.props.territory > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[4] .. " \\n"
		end
	end
	
	-- Fix
	if (smart.defense_count) then
		props = props .. " \\n" .. clr_gr .. str_wrfr[7] .. ": " .. clr_w .. tostring(smart.defense_count) --.. "\\n"
	end
	if (smart.max_population) then
		props = props .. " \\n" .. clr_gr .. str_wrfr[8] .. ": " .. clr_w .. tostring(smart.max_population) .. "\\n"
	end
	
	local f = false
	if (smart.target_smarts) then
		for target,_ in pairs(smart.target_smarts) do	
			if not (f) then
				f = true
				--props = props .. clr_b .. " \\n \\n------------------------"	
				props = props .. " \\n" .. clr_b .. " \\n" .. str_wrfr[17] .. " \\n" .. clr_gr
			end		
		
			local other = alife_object(target)
			
			if (other) then
				local otherWarfare = translate_smart_name(other:name()) or other:name()			
				local other_level = game.translate_string(alife():level_name(game_graph():vertex(other.m_game_vertex_id):level_id()))
				
				props = props .. "\\n" .. clr_gr .. otherWarfare .. "\\n"
			end
		end
	end
	
    printd(1, smart:name())
	return props
end

function get_target_info(smart, visible)
    printd(0, smart:name())
	
    local owning_faction = warfare_names.faction_names[smart.owning_faction]
	local warfareName = translate_smart_name(smart:name())	or smart:name()
	local props = clr_o .. warfareName .. " \\n"
	props = props .. clr_o .. "................................\\n "	.. clr_gr

	if (smart.owning_faction and visible) then
		props = props .. " \\n" .. clr_gr .. str_wrfr[6] .. ": " .. clr_w .. game.translate_string(smart.owning_faction) .. " \\n"
	end

	if (smart.props) then
		if (smart.props.base > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[2] .. " \\n"
		end
		
		if (smart.props.resource > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[3] .. " \\n"
		end

		if (smart.props.territory > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[4] .. " \\n"
		end
	end

	props = props .. " \\n" .. clr_gr .. str_wrfr[8] .. ": " .. clr_w .. tostring(smart.max_population) .. " \\n"
	props = props .. " \\n \\n"
	
	if (manual_point and manual_point[1] and smart.id == manual_point[1]) then
		local diff = round_idp(game.get_game_time():diffSec(manual_point[2])/60)
		local remaining = (warfare_options.options.auto_capture_wait_time) - diff
		
		if (remaining >= 0) then
			props = props.." \\n" .. clr_gr .. str_wrfr[10] .. ": " .. clr_y .. strformat(str_wrfr[14] , remaining) .. " \\n"
		end
	end
	
    printd(1, smart:name())
	return props
end

-- gets information for the smart terrain hint
function get_warfare_info(smart)
    printd(0, smart:name())
	

    local owning_faction_ru = warfare_names.faction_names[smart.owning_faction]
	local warfareName = translate_smart_name(smart:name())
	
	local props = ""
	
	if (warfareName) then
		props = clr_o .. warfareName .. " \\n"
		props = props .. clr_o .. "................................\\n "	.. clr_gr
		
		if (warfare_options.options.debug_logging) then
			props = props .. "\\n" .. smart:name() .. " | id="..smart.id .. "\\n"
		end
	else
		props = "\\n" .. smart:name() .. "\\n"
	end
	
	if (manual_point and manual_point[1] and smart.id == manual_point[1]) then
		local diff = round_idp(game.get_game_time():diffSec(manual_point[2])/60)
		local remaining = (warfare_options.options.auto_capture_wait_time) - diff
		
		if (remaining >= 0) then
			props = props.." \\n" .. clr_gr .. str_wrfr[10] .. ": " .. clr_y .. strformat(str_wrfr[14] , remaining) .. " \\n"
		end
	end
	
	if (smart.props) then				
		if (smart.props.base > 0 and smart.props.resource > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[2] .. " + " .. str_wrfr[3] .. " \\n"
		elseif (smart.props.base > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[2] .. " \\n"
		elseif (smart.props.resource > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[3] .. " \\n"
		elseif (smart.props.territory > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[4] .. " \\n"
		elseif (smart.props.lair > 0) then
			props = props .. " \\n" .. clr_gr .. str_wrfr[5] .. " \\n"
		end
	end	
	if (smart.owning_faction) then
		props = props .. " \\n" .. clr_gr .. str_wrfr[6] .. ": " .. clr_w .. game.translate_string(smart.owning_faction) .. "\\n"
	end
	
	props = props .. " \\n" .. clr_gr .. str_wrfr[7] .. ": " .. clr_w .. tostring(smart.defense_count) --.. "\\n"	
	props = props .. " \\n" .. clr_gr .. str_wrfr[8] .. ": " .. clr_w .. tostring(smart.max_population) .. "\\n"
	
	if defense_timers[smart.id] then
		--props = props .. "\\n----------\\n"	
		
		local defense_timer = defense_timers[smart.id]
		local next_defense = defense_next_update[smart.id]
		
		local diff = game.get_game_time():diffSec(defense_timer)
		local remaining = (next_defense*60) - diff
		-- xQd, show the timer in hours and minutes
		--remaining = round_idp(remaining / 60)
		if remaining <= 3600 then -- show in minutes if less than an hour left
			remaining = strformat(str_wrfr[14] , round_idp(remaining / 60))
		else 					  -- otherwise show in hours and minutes
			local remaining_hrs_round = math.floor((remaining / 60)/60)
			local remaining_hrs_float = (remaining / 60)/60
			local remaining_mins_diff = round_idp((remaining_hrs_float - remaining_hrs_round) * 60)
			remaining = strformat(str_wrfr[13] , remaining_hrs_round, remaining_mins_diff)
		end
		props = props .. " \\n" .. clr_gr .. str_wrfr[11] .. ": " .. clr_y .. remaining
		-- xQd end
	end
	
	if patrol_timers[smart.id] and smart.owning_faction and warfare_options.options.factions[smart.owning_faction] and (warfare_options.options.factions[smart.owning_faction].max_patrol_squads > 0) then
		--props = props .. "\\n----------\\n"
		
		local patrol_timer = patrol_timers[smart.id]
		local next_patrol = patrol_next_update[smart.id]
		
		local diff = game.get_game_time():diffSec(patrol_timer)
		local remaining = (next_patrol*60) - diff
		-- xQd, show the timer in hours and minutes
		--remaining = round_idp(remaining / 60)
		if remaining <= 3600 then -- show in minutes if less than an hour left
			remaining = strformat(str_wrfr[14] , round_idp(remaining / 60))
		else 					  -- otherwise show in hours and minutes
			local remaining_hrs_round = math.floor((remaining / 60)/60)
			local remaining_hrs_float = (remaining / 60)/60
			local remaining_mins_diff = round_idp((remaining_hrs_float - remaining_hrs_round) * 60)
			remaining = strformat(str_wrfr[13] , remaining_hrs_round, remaining_mins_diff)
		end
		props = props .. " \\n" .. clr_gr .. str_wrfr[12] .. ": ".. clr_y .. remaining
	end
	
	local f = false
	if (smart.target_smarts) then
		for target,_ in pairs(smart.target_smarts) do	
			if not (f) then
				f = true
				--props = props .. clr_b .. " \\n \\n------------------------"	
				props = props .. " \\n" .. clr_b .. " \\n" .. str_wrfr[17] .. " \\n" .. clr_gr
			end		
		
			local other = alife_object(target)
			
			if (other) then
				local otherWarfare = translate_smart_name(other:name()) or other:name()			
				local other_level = game.translate_string(alife():level_name(game_graph():vertex(other.m_game_vertex_id):level_id()))
				
--				props = props .. "\\n" .. clr_gr .. otherWarfare .. " ("..other_level..")\\n"
				props = props .. "\\n" .. clr_gr .. otherWarfare .. "\\n"
			end
		end
	end
	
	if (invasions[smart.id]) then
		local other = invasions[smart.id][1] and alife_object(invasions[smart.id][1])
		local otherName = translate_smart_name(other:name())
		local other_level = game.translate_string(alife():level_name(game_graph():vertex(other.m_game_vertex_id):level_id()))
		otherName = otherName or smart:name()
		
		--props = props .. clr_b .. " \\n \\n------------------------"	
		props = props .. " \\n" .. clr_b .. " \\n" .. str_wrfr[18]
		props = props .. " \\n" .. clr_gr .. str_wrfr[15] .. ": " .. clr_w .. otherName .."\\n"
		props = props .. " \\n" .. clr_gr .. str_wrfr[16] .. ": " .. clr_w .. invasions[smart.id][2] .. "\\n"
		
		local diff = game.get_game_time():diffSec(invasions[smart.id][3] or game.get_game_time())
		local wait = invasions[smart.id][4] or 0

		local remaining = wait - (diff/60)
		remaining = strformat(str_wrfr[14] , remaining)
		--props = props .. clr_gr .. "\\nInvasion departure: ".. clr_y .. remaining 
	end
	
	
	if under_attack[smart.id] then
		
		props = props .. " \\n" .. clr_r .. " \\n" .. "Enemy is advancing on this location!"
	
	end
	
	
    printd(1, smart:name())

	return props
end

-- Includes both squads currently at the smart, as well as those targeting it
-- includes stationary squads
-- WARNING: Capable of unregistering squads!
function squad_count(smart, faction)
    printd(0, smart:name())
	local squadCount = 0
	
	if not (smart.owning_faction) then
		check_owner(smart)
	end			
	
	for sid,_ in pairs(warfare.registered_squads[faction]) do
		local squad = sid and alife_object(sid)

		if (squad and squad:clsid() == clsid.online_offline_group_s) and warfare.registered_squads[faction][sid] then
			if (squad:get_squad_community() == faction) and not (axr_companions.companion_squads[squad.id]) and not (warfare.ignore[squad:section_name()]) then
				local power = sim_offline_combat.calculate_squad_power(squad)
				
				if (power and power > 0 and squad:npc_count() > 0 and squad.current_target_id and squad.current_target_id == smart.id) then
					squadCount = squadCount + 1
				end
			end
		else
			warfare.registered_squads[faction][sid] = nil
		end
	end
	
    printd(1, smart:name())
	
	--printf("squad count=%s", tostring(squadCount))
	--printf("smart=%s", smart:name())
	--printf("faction=%s", faction)
	
	return squadCount
end

-- get squads count and power of a single faction's idle squads at the point
-- includes stationary squads
-- WARNING: Capable of unregistering squads!
function squad_count_defending(smart, faction) 
    printd(0, smart:name())
	
	local squadCount = 0
	local squadPower = 0
	
	if not (smart.owning_faction) then		
		check_owner(smart)
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		if (squad) and (squad:clsid() == clsid.online_offline_group_s) and warfare.registered_squads[faction][sid] then
			if (squad:get_squad_community() == faction and squad.current_action == 1) and (not axr_companions.companion_squads[squad.id]) and (not warfare.ignore[squad:section_name()]) then
				local power = sim_offline_combat.calculate_squad_power(squad)
				
				if (power and power > 0 and squad:npc_count() > 0 and squad.current_target_id and squad.current_target_id == smart.id) then
					squadCount = squadCount + 1
					squadPower = squadPower + power
				end
			end
		else
			warfare.registered_squads[faction][sid] = nil
		end
	end
    
    printd(1, smart:name())
	
	return squadCount,squadPower
end

-- get squads count and power of a single faction's idle squads at the point
-- counts stationary squads separately
-- WARNING: Capable of unregistering squads!
function squad_count_detailed(smart, faction) 
    printd(0, smart:name())
	
	local squadCount = 0
	local squadPower = 0
	local stationary = 0
	
	if not (smart.owning_faction) then		
		check_owner(smart)
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		
		if (squad) and (squad:clsid() == clsid.online_offline_group_s) and warfare.registered_squads[faction][sid] then
			if squad_is_commandable(squad) then
				if (squad:get_squad_community() == faction and squad.current_action == 1) then
					local power = sim_offline_combat.calculate_squad_power(squad)
					
					if (power and power > 0 and squad:npc_count() > 0 and squad.current_target_id and squad.current_target_id == smart.id) then
						squadCount = squadCount + 1
						squadPower = squadPower + power
					end
				end
			elseif squad and (squad:clsid() == clsid.online_offline_group_s) and warfare.registered_squads[faction][sid] and (sim_offline_combat.stationary_squads[squad:section_name()]) and (not random_patrols[squad.id]) then
				if (squad:get_squad_community() == faction and squad.current_action == 1) and (not axr_companions.companion_squads[squad.id]) and (not warfare.ignore[squad:section_name()]) then
					stationary = stationary + 1
				end
			end
		else
			warfare.registered_squads[faction][sid] = nil
		end
	end
    
    printd(1, smart:name())
	
	return squadCount,squadPower,stationary
end



-- get squads count and power of all factions in a smart
-- includes stationary squads
-- WARNING: Capable of unregistering squads!
function squad_count_defending_all(smart)
    printd(0, smart:name())
	
	local squadCount = {}
	local squadPower = {}
	
	if not (smart.owning_faction) then		
		check_owner(smart)
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)
		if squad and (squad:clsid() == clsid.online_offline_group_s) then
			local faction = squad:get_squad_community()
			
			if warfare_factions.factions_p[faction]                         -- squad is from warfare faction
			and warfare.registered_squads[faction][sid]                     -- squad is registered in warfare
			and (squad.current_action == 1)                                 -- squad arrived to smart
			and not (axr_companions.companion_squads[squad.id]) and not (warfare.ignore[squad:section_name()]) then
				local power = sim_offline_combat.calculate_squad_power(squad)
				
				if (power and power > 0 and squad:npc_count() > 0 and squad.current_target_id and squad.current_target_id == smart.id) then
					squadCount[faction] = (squadCount[faction] or 0) + 1
					squadPower[faction] = (squadPower[faction] or 0) + power
				end
			end
		elseif squad then
			local faction = squad:get_squad_community()
			if faction then
				warfare.registered_squads[faction][sid] = nil
			end
		end
	end
    
    printd(1, smart:name())
	
	return squadCount,squadPower
end

function squad_count_targeting(smart, faction)
	printd(0, smart:name())
	
	local squads = SIMBOARD.smarts[smart.id].squads
	local squadCount = 0
	
	if not (smart.owning_faction) then
		check_owner(smart)
	end
						
	for sid,_ in pairs(squads) do
		local squad = sid and alife_object(sid)

		if (squad and squad:clsid() == clsid.online_offline_group_s) then
			if (squad.registered_with_warfare and squad:get_squad_community() == faction and squad.current_action == 0) and not (axr_companions.companion_squads[squad.id]) then
				squadCount = squadCount + 1
			end
		else
			warfare.registered_squads[faction][sid] = nil
		end
	end
    
    printd(1, smart:name())
	
	return squadCount
end


-- used to check if a squad is qualified to be handled by Warfare, to be moved around or used for invasion or defense forces
-- essentially used to stop stationary, story, companion, patrol, random patrol, or invalid squads from moving around unintentionally
function squad_is_commandable(squad, random_patrol_override)
	
	if squad 
	and squad.registered_with_warfare 
	and (squad:clsid() == clsid.online_offline_group_s) 
	and (not warfare.ignore[squad:section_name()]) 
	and (not sim_offline_combat.stationary_squads[squad:section_name()]) 
	and (not squad.patrol_table) 
	and (not axr_companions.companion_squads[squad.id]) then
		if (not random_patrol_override) and (not random_patrols[squad.id]) then
			return true
		elseif random_patrol_override then		-- loner/ecolog random patrols are handled by process_loner/process_ecolog
			return true
		end
	end
	
	return false
end


function check_owner(smart)
	if not (smart) then
		return
	end
	
    printd(0, smart:name())

	if not (smart.check_owner_timer) then
		smart.check_owner_timer = game.get_game_time()
	end

	if (not SIMBOARD.smarts[smart.id]) then
		smart.owning_faction = "none"
		return
	end
	
	if not (SIMBOARD.smarts[smart.id].squads) then
		smart.owning_faction = "none"
		return
	end

	if (owner == "monster") then
		owner = "none"
	end

	local squadCount, squadPowers = squad_count_defending_all(smart)
	
	-- New faction owner = who has highest squad count on the smart + smart has no owner
	local owner = "none"
	for faction,count in pairs(squadCount) do	
		if (faction ~= monster) then
			if (faction ~= "stalker" and faction ~= "ecolog" and faction ~= "zombied") and (smart.owning_faction == "stalker" or smart.owning_faction == "ecolog" or smart.owning_faction == "zombied") and not is_factions_enemies(faction, smart.owning_faction) then		-- if current owner is loner/ecologist/zombified, they auto-lose non-base points to other neutral factions
				if ((smart.props) and (smart.props.base < 1)) or (squadCount[smart.owning_faction] and count and squadCount[smart.owning_faction] < count) then																					-- loners/ecologist auto-lose resources/territories to other neutral factions, but bases require the faction to have more squads present
					if enable_debug then
						printf("transferring control of " .. smart:name() .. " from " .. smart.owning_faction .. " to " .. faction)
					end
					owner = faction 																																	-- relinquish control to other faction
					break
				end
			elseif (owner == "none" or faction == smart.owning_faction) then	 														-- when a faction is already the owner	
				owner = faction
			elseif (squadCount[owner] < count and smart.owning_faction == "none") then													-- current owner has fewer squads and smart appears empty (SIMBOARDs?)			
				owner = faction
			end
		end
	end
	
	--printf("- owner of [%s] is [%s]", smart:name(), owner)
	
	if (manual_point and manual_point[1] == smart.id) then
		if (owner ~= warfare.actor_faction) then
			owner = "none"
		end
	end

	-- Want to clear if a non-enemy faction takes point
	if (warfare.influence_levels[smart.id]) then
		local enemies = (is_factions_enemies(owner, warfare.actor_faction) or owner == "stalker" or owner == "ecolog")

		if not (enemies) then
			local val = warfare.influence_levels[smart.id]
			warfare.actor_influence_points = warfare.actor_influence_points + val
			warfare.influence_levels[smart.id] = nil
		end
	end
			
	-- Store information in smart_terrain; no need to calculate again elsewhere
	smart.defense_count = squadCount[owner] or 0
	smart.defense_power = squadPowers[owner] or 0
	
	if (smart.defense_count > 25) then
		local smrt_name = game.translate_string("st_" .. smart:name() .. "_name")
--		actor_menu.set_msg(1, strformat(str_wrfr[19], smrt_name, tostring(smart.defense_count)), 3) -- TODO: figure out how to stop this being spammed
		--printf("smart " .. smart:name() .. " has over 25 squads! max pop = " .. tostring(smart.max_population))
	end
	
	if not (smart.last_owner) then
		smart.last_owner = owner
	end

	if not previous_owner[smart.id] and (owner ~= "none") then								-- previous owner cannot be "none"
		previous_owner[smart.id] = owner
	end

	if smart_owners[smart.id] ~= nil and smart_owners[smart.id] ~= "none" and game.get_game_time():diffSec(smart.check_owner_timer) < 300 then
		smart.owning_faction = smart_owners[smart.id]
		smart.last_owner = smart_owners[smart.id]
	elseif (smart.last_owner ~= "none" and warfare_options.options.factions[smart.last_owner].keep_last_base) then
		if (warfare_factions.faction_information[smart.last_owner] and warfare_factions.faction_information[smart.last_owner].base_count <= 1) then
			smart.owning_faction = smart.last_owner
			smart.last_owner = smart.last_owner
		end
	else
		smart.owning_faction = owner
	end
	
	if (smart.last_owner ~= smart.owning_faction) then	
		local squads = patrol_squads[smart.id]
		
		if (squads) then
			for squad_id, target_id in pairs(squads) do
				local squad = squad_id and alife_object(squad_id)

				if (squad and squad:clsid() == clsid.online_offline_group_s) and (not warfare.ignore[squad:section_name()]) and (not sim_offline_combat.stationary_squads[squad:section_name()]) then
					if (squad:get_squad_community() ~= smart.owning_faction) then
						sim_squad_warfare.set_target(squad, smart.id)
										
						patrol_squads[smart.id][squad.id] = {
							target = smart.id,
							stay_time = nil,
							arrive_time = nil
						}
					end
				else					
					patrol_squads[smart.id][squad_id] = nil
				end
			end
		end
		
		if (smart.target_smarts) then		
			smart:hide()
			smart.target_smarts = {}
			invasions[smart.id] = nil
			smart:show()			
		end
	end
	
	if (previous_owner[smart.id]) and (smart.owning_faction ~= "none") and (previous_owner[smart.id] ~= smart.owning_faction) then
		if (smart.props) and (smart.props.base > 0) then
			-- reset timer if enemy faction takes over a base
			if is_factions_enemies(smart.owning_faction, previous_owner[smart.id]) then
				reset_defense_timer[smart.id] = 1											-- a non-nil value here will cause the spawn time to reset, which will happen when a base's ownership changes
				if enable_debug then
					printf("resetting defense timer of base %s due to ownership change from %s to %s", smart:name(), previous_owner[smart.id], smart.owning_faction)
				end
			-- or reset timer if a legit faction steals a base from another legit faction. Don't reset for loner/ecolog changes
			elseif (previous_owner[smart.id] ~= "stalker" and previous_owner[smart.id] ~= "ecolog" and smart.owning_faction ~= "stalker" and smart.owning_faction ~= "ecolog") then
				reset_defense_timer[smart.id] = 1											-- a non-nil value here will cause the spawn time to reset, which will happen when a base's ownership changes
				if enable_debug then
					printf("resetting defense timer of base %s due to ownership change from %s to %s", smart:name(), previous_owner[smart.id], smart.owning_faction)
				end
			end
		end
		
		previous_owner[smart.id] = smart.owning_faction								-- the new owner becomes the previous owner
	end
	
	if (smart.last_owner) then
		smart.last_owner = smart.owning_faction
	end
    
    printd(1, smart:name())
end


-- unused function
function faction_enemy_present(smart, faction)
end

-- unused function
function calculate_target_density(smart)
	printd(0, smart:name())
	
	local level = game_graph():vertex(smart.m_game_vertex_id):level_id()
	local linked = level_targets.level_links[level]
	local smart_collection = {}
	
	for i=1,#warfare_levels.level_information[level].smarts do
		smart_collection[#smart_collection+1] = warfare_levels.level_information[level].smarts[i]
	end
	
	for lvl,_ in pairs(linked) do
		for i=1,#warfare_levels.level_information[lvl].smarts do
			smart_collection[#smart_collection+1] = warfare_levels.level_information[level].smarts[i]
		end
	end
	
	local targets = {}
	
	local enemy_points = 0
	local aggregate_distance = 0
	
	-- bases will be considered as being closer, then owned resources are taken at their current value, while territory and lairs are viewed as being further away as they matter less.
	local base_weight = 0.75
	local resource_weight = 1
	local territory_weight = 1.5
	local lair_weight = 1.5
	
	for i=1,#smart_collection do
		local other = smart_collection[i] and alife_object(smart_collection[i])
		
		if (other and other.props) then
			local owner = other.owning_faction
			local other_level = game_graph():vertex(other.m_game_vertex_id):level_id()			

			if not (smart.global_position) then	
				global_position.from(smart)
			end

			if not (other.global_position) then
				global_position.from(other)
			end

			local dist = warfare.distance_to_xz_sqr(smart.global_position, other.global_position)
			
			if owner and owner ~= "none" and (is_factions_enemies(smart.owning_faction, owner) or ((owner == "stalker" or owner == "ecolog") and other.props.base < 1)) then				-- include loner-owned resources in targeting
				local points = 0
			
				if (other.props.base > 0) then
					points = 1.5
				elseif (other.props.resource > 0) then
					points = 1.2
				elseif (other.props.territory > 0) then
					points = 1.0
				elseif (other.props.lair > 0) then
					points = 0.75
				end
				
				-- Distant levels shouldn't be included in the weight as much.
				if (other_level ~= level) then
					points = points * 0.5
				end
			
				aggregate_distance = aggregate_distance + dist
				enemy_points = enemy_points + points
			end
		end
	end
	
	local final_distance = aggregate_distance / enemy_points
	
	printd(1, smart:name())
	
	return final_distance
end

function find_random_patrol_target(smart, faction, sid)
	printd(0, "find_random_patrol_target: "..(smart and smart:name() or "spawn"))

	local smart_level = smart and game_graph():vertex(smart.m_game_vertex_id):level_id()
	local smartCollection = {}
	local targets = {}
	local backup_targets = {}

	for _,lvl in pairs(level_targets.active_levels) do
		local smarts = warfare_levels.level_information[lvl].smarts
			
		for i=1,#smarts do
			smartCollection[#smartCollection+1] = smarts[i]
		end
	end	
	
	for i=1,#smartCollection do
		local other = smartCollection[i] and alife_object(smartCollection[i])		
		local priority = 0

		if (smart) then																								-- only check priorities if the squad has spawned
			if (other) then
				local other_faction = other.owning_faction or "none"
				local other_level = game_graph():vertex(other.m_game_vertex_id):level_id()
				
				-- Duty random patrols target lairs only. Other factions operate normally
				if (faction ~= "dolg") then
					if (warfare.influence_levels[other.id] and faction == warfare.actor_faction) then
						priority = priority + (warfare.influence_levels[other.id] * warfare_options.options.actor_influence_weight)
					end
					
					if other.props[faction] then
						priority = priority + (other.props[faction] * warfare_options.options.factions[faction].faction_flag_priority)
					end
					
					if (other.props.base > 0) then
						priority = priority + (other.props.base * warfare_options.options.factions[faction].base_priority)
					end
					
					if (other.props.resource > 0) then			
						priority = priority + (other.props.resource * warfare_options.options.factions[faction].resource_priority)
					end
					
					if (other.props.territory > 0 and other.props.resource < 1 and other.props.base < 1) then	
						priority = priority + (other.props.territory * warfare_options.options.factions[faction].territory_priority)
					end
				
					local p = "lvl_"..other_level.."_priority"
					if warfare_options.options.factions[faction][p] then
						priority = priority + warfare_options.options.factions[faction][p]
					end

					if (other.id == smart.id) then
						priority = 0
					end
					
					if (other_faction ~= "none") and (is_factions_enemies(faction, other_faction)) and (sid) then				-- random patrols only attack hostile locations if they are much stronger than enemy presence
						local squad = sid and alife_object(sid)
						local enemy_squads = SIMBOARD.smarts[other.id].squads
						local enemy_power = 0
						local patrol_power = sim_offline_combat.calculate_squad_power(squad)
						for enemy_id,_ in pairs(enemy_squads) do
							local enemy_squad = enemy_id and alife_object(enemy_id)
							enemy_power = enemy_power + sim_offline_combat.calculate_squad_power(enemy_squad)
						end
						local attack_chance = (patrol_power / enemy_power - 1) * 100
						if (patrol_power) and (patrol_power > enemy_power) and (attack_chance > math.random(1,100)) then
							priority = 2
						else
							priority = 0
						end
					end

					-- heavily de-prioritize pure lairs
					if (other.props.resource < 1 and other.props.base < 1 and other.props.territory < 1) then				
						priority = -1000
					end
					
					-- ISG extremely interested in targeting labs
					if (faction == "isg") and lab_entrance_smarts[other:name()] then
						priority = 10 * priority
					end
					
					-- prevent main base attacks if option is enabled
					if warfare_options.options.prevent_mainbase_attacks and main_bases[other:name()] then
						priority = -1000
					end
				
				-- Duty random patrol goes to lairs
				elseif (other.props.lair > 0) then
					priority = 2
				end
			end

		elseif (other.owning_faction ~= "none") and is_factions_enemies(faction, other.owning_faction) then					-- during the spawning phase, forbid hostile locations
			priority = 0
		elseif ( (faction == "stalker") or (faction == "ecolog") ) and (other.owning_faction ~= "none") and not is_factions_enemies(faction, other.owning_faction) then		-- loners/ecolog can spawn on any neutral location
			priority = 2
		elseif (faction == other.owning_faction) and (faction ~= "zombied") then																	-- faction random patrols can spawn on their own locations
			priority = 2
		elseif (other.owning_faction == "none")	then																	-- if the squad has trouble spawning, spawn them on any vacant location
			priority = 1
		end
		
		if (priority > 1) then
			targets[#targets+1] = other
		elseif (priority > 0) then
			backup_targets[#backup_targets+1] = other
		end
		
	end

	-- used for spawning and re-targeting
	if (#targets > 0) then
		local target = targets[math.random(#targets)]
		if enable_debug then
			if (smart) then
				printf("setting target of %s random patrol to: %s", faction, target:name())
			else
				printf("spawning %s random patrol on %s", faction, target:name())
			end
		end
		return target.id
	end

	-- only used for spawning
	if (#backup_targets > 0) then
		local target = backup_targets[math.random(#backup_targets)]
		if enable_debug then
			printf("spawning %s random patrol on %s", faction, target:name())
		end
		return target.id
	end

	printd(1)

	return smart.id																		-- if no target is valid, the squad will sit on their current location until the next update
end

function find_targets(smart, faction_override, overflow_squad)
	printd(0, smart:name())
	
	local level = game_graph():vertex(smart.m_game_vertex_id):level_id()
	local linked = level_targets.level_links[level]	
	local currentLevelSmarts = warfare_levels.level_information[level].smarts
	local smartCollection = {}
	local faction = smart.owning_faction or "none"
	local d = smart.defense_power or 0
	
	if (faction_override) then
		faction = faction_override
		d = get_faction_power(smart, faction)
	end
	
	-- non-linked levels are included only for overflow squads
	if (warfare_options.options.factions[faction].linked_level_targeting) and not (overflow_squad) then	
		for i=1,#currentLevelSmarts do
			smartCollection[#smartCollection+1] = currentLevelSmarts[i]
		end

		for lvl,_ in pairs(linked) do
			local smarts = warfare_levels.level_information[lvl].smarts
				
			for i=1,#smarts do
				smartCollection[#smartCollection+1] = smarts[i]
			end
		end
	else
		for _,lvl in pairs(level_targets.active_levels) do
			local smarts = warfare_levels.level_information[lvl].smarts
				
			for i=1,#smarts do
				smartCollection[#smartCollection+1] = smarts[i]
			end
		end
	end
	
	local targets = {}
	local mainbase_targets = {}  -- backup array if targets array is empty
	
	if (faction == "monster") then
		return
	end
	
	for i=1,#smartCollection do
		-- Do not even factor in which level this base is on. We want to have fluid borders at this point.
		local other = smartCollection[i] and alife_object(smartCollection[i])		
		
		if (other and other.props) then		
			local priority = 0
			local other_faction = other.owning_faction or "none"
			local d2 = other.defense_power or 0				
			local other_level = game_graph():vertex(other.m_game_vertex_id):level_id()			
			local other_resources = warfare_levels.level_information[other_level].resource_count
			local cName = translate_smart_name(smart:name())
			local pName = translate_smart_name(other:name())
			
			if not (cName) then
				cName = smart:name()
			end
			
			if not (pName) then
				pName = other:name()
			else
				pName = pName.." ("..other:name()..")"
			end
			
			if (warfare.influence_levels[other.id] and faction == warfare.actor_faction) then
				priority = priority + (warfare.influence_levels[other.id] * warfare_options.options.actor_influence_weight)
			end
			
			if other.props[faction] then
				priority = priority + (other.props[faction] * warfare_options.options.factions[faction].faction_flag_priority)
			end
			
			if (other.props.base > 0) then
				priority = priority + (other.props.base * warfare_options.options.factions[faction].base_priority)
			end
			
			if (other.props.resource > 0) then
				priority = priority + (other.props.resource * warfare_options.options.factions[faction].resource_priority)
			end
			
			if (other.props.territory > 0 and other.props.resource < 1 and other.props.base < 1) then
				priority = priority + (other.props.territory * warfare_options.options.factions[faction].territory_priority)
			end
			
			if (other.target_smarts) then
				if (other.target_smarts[smart.id]) then
					priority = priority + warfare_options.options.factions[faction].is_being_targeted_priority
				end
			end
			
			if (other.player_target_smarts) then
				if (other.player_target_smarts[smart.id]) then
					priority = priority + warfare_options.options.factions[faction].is_being_targeted_priority
				end
			end
				
			if (is_factions_enemies(faction, other_faction)) then
				local diff = d - d2

				if (diff > 0) then
					priority = priority + warfare_options.options.factions[faction].target_weaker_priority
				else
					priority = priority + warfare_options.options.factions[faction].target_stronger_priority
				end
			end
			
			-- labs and underground locations will not be targets of bases
			if ((other_level > 19) and (other_level < 27)) or (other_level == 29) or (other_level == 31) then
				priority = -1000
			end
			
			local other_lvl_name = alife():level_name(other_level)
			local p = "lvl_"..other_lvl_name.."_priority"
			if warfare_options.options.factions[faction][p] then
				priority = priority + warfare_options.options.factions[faction][p]
			end

			if not (is_factions_enemies(faction, other_faction) or other_faction == "none") and (other_faction ~= "stalker") and (other_faction ~= "ecolog") then		
				priority = 0
			end

			-- slight priority boost for empty resources or bases, or resources owned by neutral loner/ecolog
			if (other_faction == "none" or ((other_faction == "stalker" or other_faction == "ecolog") and other.props.base < 1 and not is_factions_enemies(faction, other_faction))) and (other.props.resource > 0 or other.props.base > 0) then
				priority = priority * 1.2
			end

			-- Monolith will not be allowed to target southern levels unless they are the player faction
			if IsStoryMode() and (faction == "monolith") and ( (other_level < 12) or (other_level > 31) ) then
				if (faction == warfare.actor_faction) then
					priority = priority * 0.2			-- lower priority for southern levels if actor faction
				else
					priority = -1000
				end
			end

			-- normal factions will not be allowed to target Radar or Pripyat until the Brain Scorcher is disabled
			if (faction ~= "monolith") and (faction ~= "greh") and (faction ~= "zombied") and ( (other_level == 13) or (other_level == 16) ) and not has_alife_info("bar_deactivate_radar_done") then
				priority = -1000
			end
			
			-- heavily de-prioritize pure lairs
			if (other.props.resource < 1 and other.props.base < 1 and other.props.territory < 1) then
				priority = -1000
			end
			
			-- normal factions cannot travel between Yantar/Dead City until the Miracle Machine is disabled
			if (faction ~= "monolith") and (faction ~= "greh") and (faction ~= "zombied") and ( (level == 10 and other_level == 11) or (level == 11 and other_level == 10) ) and not has_alife_info("yan_labx16_switcher_primary_off") then
				priority = -1000
			end
			
			-- ISG extremely interested in targeting labs
			if (faction == "isg") and lab_entrance_smarts[other:name()] then
				priority = 10 * priority
			end
			
			if (priority > 0) then
				priority = priority + (warfare_options.options.factions[faction].target_resource_priority * other_resources)

				if (other_faction ~= "none" and warfare_factions.faction_information[faction] ~= nil) then
					local faction_bases = warfare_factions.faction_information[faction].base_count
					local faction_resources = warfare_factions.faction_information[faction].resource_count
					local faction_est = faction_bases + faction_resources

					if (warfare_factions.faction_information[other_faction] ~= nil) then
						local other_faction_bases = warfare_factions.faction_information[other_faction].base_count
						local other_faction_resources = warfare_factions.faction_information[other_faction].resource_count
						local other_faction_est = other_faction_bases + other_faction_resources
						
						if (faction_est > other_faction_est) then
							priority = priority + warfare_options.options.factions[faction].target_faction_weaker_priority
						elseif (other_faction_est > faction_est) then
							priority = priority + warfare_options.options.factions[faction].target_faction_stronger_priority
						end
					end
				end

				if (other_level == level) then						
					priority = priority + warfare_options.options.factions[faction].target_on_same_level_priority
				end
				
				-- greatly de-prioritize loner/ecolog bases, but not to zero
				if not (is_factions_enemies(faction, other_faction) or other_faction == "none") and (other.props.base > 0) and ((other_faction == "stalker") or (other_faction == "ecolog")) then
					priority = priority / 1000
				end

				local distance = fetch_smart_distance(smart,other)
				local inv_dist = (1 / distance)
				
				-- prevent main base attacks if option is enabled
				if warfare_options.options.prevent_mainbase_attacks and main_bases[other:name()] and (other_faction ~= "none") then
					mainbase_targets[#targets+1] = { priority * inv_dist, other.id }
				else
					targets[#targets+1] = { priority * inv_dist, other.id }  -- otherwise add to standard target array
				end

			end
		end
	end

	table.sort(targets, function(a, b)
		return math.abs(a[1]) > math.abs(b[1])
	end)
	
	printd(1, smart:name())
	
	-- if targets array is empty and mainbase array isn't, use mainbase targets
	if (#targets < 1) and (#mainbase_targets > 0) then
		table.sort(mainbase_targets, function(a, b)
			return math.abs(a[1]) > math.abs(b[1])
		end)
	
		return mainbase_targets
	end
	
	return targets
end



-- used to handle overflow squads
-- overflow squads that arent part of an invasion force will be tasked to nearby empty valuable points, nearby bases that have capacity (or invasion force capacity), or hostile targets as a last resort
function find_targets_for_overflow(smart, faction, search_all_levels)
	
	local level = game_graph():vertex(smart.m_game_vertex_id):level_id()
	local linked = level_targets.level_links[level]	
	local currentLevelSmarts = warfare_levels.level_information[level].smarts
	local smartCollection = {}
	local targets = {}
	local d = smart.defense_power or 0
	local faction_props = warfare_options.options.factions[faction]
	
	if (faction) then
		d = get_faction_power(smart, faction)
	end
	
	-- search all levels
	if (search_all_levels) or not (faction_props.linked_level_targeting) then
		for _,lvl in pairs(level_targets.active_levels) do
			local smarts = warfare_levels.level_information[lvl].smarts
				
			for i=1,#smarts do
				smartCollection[#smartCollection+1] = smarts[i]
			end
		end
	-- accumulate valid smart terrains on-level and on linked-levels
	else
		for i=1,#currentLevelSmarts do
			smartCollection[#smartCollection+1] = currentLevelSmarts[i]
		end

		for lvl,_ in pairs(linked) do
			local smarts = warfare_levels.level_information[lvl].smarts
				
			for i=1,#smarts do
				smartCollection[#smartCollection+1] = smarts[i]
			end
		end
	end

	if (faction == "monster") then
		return
	end

	for i=1,#smartCollection do
		local other = smartCollection[i] and alife_object(smartCollection[i])		
		
		if (other and other.props) then		
			local priority = 0
			local other_faction = other.owning_faction or "none"
			local d2 = other.defense_power or 0
			local other_level = game_graph():vertex(other.m_game_vertex_id):level_id()			

			if (warfare.influence_levels[other.id] and faction == warfare.actor_faction) then
				priority = priority + (warfare.influence_levels[other.id] * warfare_options.options.actor_influence_weight)
			end
			
			if other.props[faction] then
				priority = priority + (other.props[faction] * faction_props.faction_flag_priority)
			end
			
			if (other.props.base > 0) then
				priority = priority + (other.props.base * faction_props.base_priority)
			end
			
			if (other.props.resource > 0) then
				priority = priority + (other.props.resource * faction_props.resource_priority)
			end
			
			if (other.props.territory > 0 and other.props.resource < 1 and other.props.base < 1) then
				priority = priority + (other.props.territory * faction_props.territory_priority)
			end
			
			-- heavily de-prioritize pure lairs
			if (other.props.resource < 1 and other.props.base < 1 and other.props.territory < 1) then
				priority = -1000
			end
			
			-- labs and underground locations will not be the target of overflow squads
			if ((other_level > 19) and (other_level < 27)) or (other_level == 29) or (other_level == 31) then
				priority = -1000
			end
			
			local p = "lvl_"..other_level.."_priority"
			if warfare_options.options.factions[faction][p] then
				priority = priority + warfare_options.options.factions[faction][p]
			end
			
			-- de-prioritize hostile locations
			if is_factions_enemies(faction, other_faction) then
				priority = priority * 0.1
			end
			
			-- neutral factions get de-prioritized
			if not (is_factions_enemies(faction, other_faction) or other_faction == "none") and (faction ~= other_faction) and (other_faction ~= "stalker") and (other_faction ~= "ecolog") then		
				priority = 0
			end
			
			if ((other_faction == "stalker") or (other_faction == "ecolog")) and not is_factions_enemies(faction, other_faction) and (other.props.base > 0) then
				priority = 0
			end
			
			-- slight priority boost for empty resources or bases, or resources owned by neutral loner/ecolog
			if (other_faction == "none" or ((other_faction == "stalker" or other_faction == "ecolog") and other.props.base < 1 and not is_factions_enemies(faction, other_faction))) and (other.props.resource > 0 or other.props.base > 0) then
				priority = priority * 1.2
			end
			
			-- Monolith will not be allowed to target southern levels unless they are the player faction
			if IsStoryMode() and (faction == "monolith") and ( (other_level < 12) or (other_level > 31) ) then
				if (faction == warfare.actor_faction) then
					priority = priority * 0.2			-- lower priority for southern levels if actor faction
				else
					priority = -1000
				end
			end

			-- normal factions will not be allowed to target Radar or Pripyat until the Brain Scorcher is disabled
			if (faction ~= "monolith") and (faction ~= "greh") and (faction ~= "zombied") and ( (other_level == 13) or (other_level == 16) ) and not has_alife_info("bar_deactivate_radar_done") then
				priority = -1000
			end
			
			-- normal factions cannot travel between Yantar/Dead City until the Miracle Machine is disabled
			if (faction ~= "monolith") and (faction ~= "greh") and (faction ~= "zombied") and ( (level == 10 and other_level == 11) or (level == 11 and other_level == 10) ) and not has_alife_info("yan_labx16_switcher_primary_off") then
				priority = -1000
			end
			
			-- nearby same-faction bases that have capacity are prioritized
			if (priority > 0) and (other_faction == faction) then
				-- check if other location has space - invasions allow more space
				local regular_squads,sq_pow,sq_stat = squad_count_detailed(smart, faction)
				if (invasions[other.id]) then
					local invasion_force_size = invasions[other.id] and invasions[other.id][2] or 0
					local guards = math.max(guard_size, sq_stat)
					local max_allowable_size = math.max((invasion_force_size + guards), other.max_population)							-- invasion prep allows temporary overflow at a given base
					if (regular_squads + sq_stat < max_allowable_size) then
						priority = priority * 1.1						-- extra priority to contribute to an invasion force
					else
						priority = 0
					end
				else
					if not (regular_squads + sq_stat < other.max_population) then
						priority = 0
					end
				end
			end
			
			if (priority > 0) then
				local distance = fetch_smart_distance(smart,other)
				local inv_dist = (1 / distance)
				
				-- extra weight on distance
				targets[#targets+1] = { priority * inv_dist * inv_dist, other.id }
			end
			
		end	
	end
	
	table.sort(targets, function(a, b)
		return math.abs(a[1]) > math.abs(b[1])
	end)
	
	return targets
	
end


-- Used after find_targets()
function pick_target(smart, squad, targets, override_checks)
	local faction = squad:get_squad_community()
	if (#targets > 0) then
		for i=1,#targets do	
			local other = targets[i][2] and alife_object(targets[i][2])
			
			if (other and other.owning_faction) then
				if override_checks then
					sim_squad_warfare.set_target(squad, other.id)
					if enable_debug then
						printf("moving %s squad on %s to %s, owned by %s", faction, smart:name(), other:name(), other.owning_faction)
					end
					break
				elseif (other.owning_faction == "none") or (is_factions_enemies(faction, other.owning_faction)) or (((other.owning_faction == "stalker") or (other.owning_faction == "ecolog" )) and (other.props.base < 1)) then			-- enable targeting of loner/ecologist-occupied pure resources
					sim_squad_warfare.set_target(squad, other.id)
					if enable_debug then
						printf("moving %s squad on %s to %s, owned by %s", faction, smart:name(), other:name(), other.owning_faction)
					end
					break
				end
			end
		end
	end
end


-- used to check existence of distances, calculate if it doesn't, and return it
function fetch_smart_distance(smart, other)

	-- if nested distance array doesn't exist yet, make it
	if not smart_terrain_distances[smart.id] then
		smart_terrain_distances[smart.id] = {}
	end
	
	-- if distance between these smart terrains hasn't been calculated before, calculate it
	if not smart_terrain_distances[smart.id][other.id] then
		-- calculate distance. Don't register values below 1, otherwise inverse value will blow up
		smart_terrain_distances[smart.id][other.id] = math.max(1, warfare.distance_to_xz_sqr(global_position.from(smart), global_position.from(other)))
	end

	return smart_terrain_distances[smart.id][other.id]
end


function check_unique_npcs(smart)
	printd(0, smart:name())
	
	if not (smart.last_unique_check) then
		smart.last_unique_check = game.get_game_time()
		local min_respawn = 45
		local max_respawn = 75
		smart.next_unique_check = math.random(min_respawn, max_respawn)
		return
	end

	if (game.get_game_time():diffSec(smart.last_unique_check) >= (smart.next_unique_check*60)) then
		smart.last_unique_check = game.get_game_time()
		local min_respawn = 45
		local max_respawn = 75
		smart.next_unique_check = math.random(min_respawn, max_respawn)
	else
		return
	end
	
	local sm_name = smart:name()
	local faction = smart.owning_faction
		
	--[[
	local tg = time_global()
	
	if smart.last_unique_check ~= nil and tg < smart.last_unique_check then
		printd(1, sm_name)
		return
	end]]
	
	--smart.last_unique_check = tg + 1000 + math.random(3*60*1000,6*60*1000) -- xQd, delay trader spawns to 3-6 real life minutes. No more instant respawning traders when they die
	
	if not (smart.online) then
		printd(2, sm_name)
		return
	end
	
	if faction == nil or faction == "none" or faction == "zombied" then
		printd(3, sm_name)
		return
	end
	
	if faction == "killer" then
		faction = "merc"
	end
	
	local trader = faction .. "_sim_squad_trader"
	local mechanic = faction .. "_sim_squad_mechanic"
	local medic = faction .. "_sim_squad_medic"
	local barman = faction .. "_sim_squad_barman"
	
	local location = nil
	local spawnTrader = false
	local spawnMechanic = false
	local spawnMedic = false
	local spawnBarman = false
	
	if (uniques[sm_name]) then	
		local tbl = uniques[sm_name]		
		local maxTraders = tbl[1]
		local maxMechanics = tbl[2]
		local maxMedics = tbl[3]
		local maxBarmen = tbl[4]
		
		local squads = SIMBOARD.smarts[smart.id].squads
		local traderCount = 0
		local mechanicCount = 0
		local medicCount = 0
		local barmanCount = 0
							
		for sid,_ in pairs(squads) do
			local s = sid and alife_object(sid)

			if (s) then
				local sq_name = s:name()
			
				-- make sure there are no vanilla traders or mechanics
				if sfind(sq_name, mechanic) or sfind(sq_name, "tech") or sfind(sq_name, "mechanic") or sfind(sq_name, "mechan") or sfind(sq_name, "yar") then
					mechanicCount = mechanicCount + 1
				elseif sfind(sq_name, barman) or sfind(sq_name, "barman") or sfind(sq_name, "barmen") or sfind(sq_name, "barkeep") or sfind(sq_name, "barkeeper") or sfind(sq_name, "povar") then
					barmanCount = barmanCount + 1
				elseif sfind(sq_name, trader) or sfind(sq_name, "trader") or sfind(sq_name, "trade") or sfind(sq_name, "sakharov") or sfind(sq_name, "ashot") or sfind(sq_name, "scientist") or sfind(sq_name, "petrenko") then 
					traderCount = traderCount + 1
				elseif sfind(sq_name, medic) or sfind(sq_name, "medic") or sfind(sq_name, "doctor") or sfind(sq_name, "medik") then
					medicCount = medicCount + 1
				end
			end
		end
		
		while traderCount < maxTraders do
			local squad = utils_obj.create_squad(trader, sm_name)
									 
			sim_squad_warfare.set_target_trader(squad, smart.id, sm_name)
			printf("SPAWNED TRADER AT "..sm_name)
			traderCount = traderCount + 1
		end
		
		while mechanicCount < maxMechanics do
			local squad = utils_obj.create_squad(mechanic, sm_name)
															  
			sim_squad_warfare.set_target_trader(squad, smart.id, sm_name)
			printf("SPAWNED MECHANIC AT "..sm_name)
			mechanicCount = mechanicCount + 1
		end
		
		while medicCount < maxMedics do
			local squad = utils_obj.create_squad(medic, sm_name)
															  
			sim_squad_warfare.set_target_trader(squad, smart.id, sm_name)
			printf("SPAWNED MEDIC AT "..sm_name)
			medicCount = medicCount + 1
		end
		
		while barmanCount < maxBarmen do
			local squad = utils_obj.create_squad(barman, sm_name)
															  
			sim_squad_warfare.set_target_trader(squad, smart.id, sm_name)
			printf("SPAWNED BARMAN AT "..sm_name)
			barmanCount = barmanCount + 1
		end
		
		--printf("end")
	end
	
	printd(4, sm_name)
end


------------------------------------------------------------
-- Callbacks
------------------------------------------------------------
function on_game_start()
	refresh_strings()

	RegisterScriptCallback("on_localization_change",refresh_strings)
end 